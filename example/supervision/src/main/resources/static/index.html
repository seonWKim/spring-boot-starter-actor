<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Actor Supervision Tree</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #4CAE50 0%, #45a049 100%);
            min-height: 100vh;
            padding: 20px;
            overflow: hidden;
        }

        .container {
            width: 100%;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #4CAE50 0%, #45a049 100%);
            color: white;
            padding: 20px 30px;
            text-align: center;
            border-radius: 12px 12px 0 0;
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .header p {
            opacity: 0.9;
            font-size: 0.9em;
        }

        .connection-status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            font-size: 0.85em;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #66BB6A;
            box-shadow: 0 0 8px #66BB6A;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .main-content {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 0;
            flex: 1;
            overflow: hidden;
        }

        .tree-panel {
            background: #f8f9fa;
            padding: 20px;
            overflow: auto;
            position: relative;
        }

        .logs-panel {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.6;
            border-left: 2px solid #ddd;
        }

        .log-entry {
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        #tree-svg {
            min-width: 100%;
            min-height: 600px;
            display: block;
        }

        /* Actor node styles */
        .actor-node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .actor-circle {
            transition: all 0.3s ease;
        }

        .actor-node:hover .actor-circle {
            stroke-width: 3;
            filter: drop-shadow(0 0 8px rgba(76, 174, 80, 0.6));
        }

        .actor-text {
            font-size: 14px;
            font-weight: 600;
            pointer-events: none;
            user-select: none;
        }

        .connection-line {
            stroke: #999;
            stroke-width: 2;
            fill: none;
        }

        /* Tooltip/Hover card */
        .hover-card {
            display: none;
            position: absolute;
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 250px;
            border: 2px solid #4CAE50;
        }

        .hover-card.active {
            display: block;
        }

        .hover-card h3 {
            color: #4CAE50;
            margin-bottom: 10px;
            font-size: 1.1em;
            border-bottom: 2px solid #4CAE50;
            padding-bottom: 8px;
        }

        .hover-card .info-row {
            margin: 8px 0;
            font-size: 0.9em;
        }

        .hover-card .info-label {
            font-weight: 600;
            color: #666;
            display: inline-block;
            min-width: 80px;
        }

        .hover-card .info-value {
            color: #333;
        }

        .hover-card .actions {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #eee;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .hover-card button {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 0.85em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .hover-card button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .btn-primary {
            background: linear-gradient(135deg, #4CAE50 0%, #45a049 100%);
            color: white;
        }

        .btn-success {
            background: #66BB6A;
            color: white;
        }

        .btn-warning {
            background: #ffc107;
            color: #333;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .modal-content h3 {
            margin-bottom: 20px;
            color: #4CAE50;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #4CAE50;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-actions button {
            flex: 1;
            padding: 10px;
        }

        .badge {
            display: inline-block;
            padding: 3px 8px;
            background: #E8F5E9;
            color: #2E7D32;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
            margin-left: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Actor Supervision Tree</h1>
            <p>Interactive hierarchical visualization</p>
            <div class="connection-status">
                <span class="status-dot" id="statusDot"></span>
                <span id="statusText">Connected</span>
            </div>
        </div>

        <div class="main-content">
            <div class="tree-panel">
                <svg id="tree-svg"></svg>
                <div class="hover-card" id="hoverCard"></div>
            </div>

            <div class="logs-panel" id="logsContainer">
                <div class="log-entry">Waiting for events...</div>
            </div>
        </div>
    </div>

    <!-- Add Worker Modal -->
    <div class="modal" id="addWorkerModal">
        <div class="modal-content">
            <h3>Add Child Actor</h3>
            <input type="hidden" id="parentActorId">
            <input type="hidden" id="parentActorType">
            <input type="hidden" id="parentActorPath">
            <div class="form-group">
                <label for="strategySelect">Supervision Strategy</label>
                <select id="strategySelect">
                    <option value="restart">Restart (unlimited)</option>
                    <option value="restart-limited">Restart (limited: 3/min)</option>
                    <option value="stop">Stop on failure</option>
                    <option value="resume">Resume (ignore failure)</option>
                </select>
            </div>
            <div class="modal-actions">
                <button class="btn-primary" onclick="confirmAddWorker()">Add Child</button>
                <button onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        let eventSource = null;
        let currentSupervisorId = 'supervisor';
        let hierarchyData = null;
        let hideCardTimeout = null;

        // Tree layout configuration
        const BASE_NODE_RADIUS = 35;
        const MIN_NODE_RADIUS = 30;
        const NODE_PADDING = 15; // Padding inside circle
        const LEVEL_HEIGHT = 150;
        const MIN_HORIZONTAL_SPACING = 150;

        // Calculate node radius based on text width
        function calculateNodeRadius(text) {
            // Create a temporary canvas to measure text width
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = '600 14px "Segoe UI", Tahoma, Geneva, Verdana, sans-serif';
            const textWidth = context.measureText(text).width;

            // Calculate radius: text width / 2 + padding, with a minimum
            const calculatedRadius = (textWidth / 2) + NODE_PADDING;
            return Math.max(MIN_NODE_RADIUS, calculatedRadius);
        }

        function initSSE() {
            eventSource = new EventSource('/api/logs/stream');

            eventSource.addEventListener('log', (event) => {
                addLogEntry(event.data);
            });

            eventSource.onopen = () => {
                document.getElementById('statusDot').style.background = '#66BB6A';
                document.getElementById('statusText').textContent = 'Connected';
            };

            eventSource.onerror = () => {
                document.getElementById('statusDot').style.background = '#dc3545';
                document.getElementById('statusText').textContent = 'Disconnected';
                setTimeout(() => {
                    eventSource.close();
                    initSSE();
                }, 3000);
            };
        }

        function addLogEntry(message) {
            const logsContainer = document.getElementById('logsContainer');

            if (logsContainer.children.length === 1 &&
                logsContainer.children[0].textContent.includes('Waiting')) {
                logsContainer.innerHTML = '';
            }

            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.textContent = message;
            logsContainer.appendChild(logEntry);

            logsContainer.scrollTop = logsContainer.scrollHeight;

            while (logsContainer.children.length > 100) {
                logsContainer.removeChild(logsContainer.firstChild);
            }
        }

        async function refreshHierarchy() {
            try {
                const response = await fetch('/api/hierarchy');
                const data = await response.json();

                if (!data.root) {
                    return;
                }

                hierarchyData = data.root;
                currentSupervisorId = hierarchyData.actorId;
                drawTree(hierarchyData);
            } catch (error) {
                console.error('Error refreshing hierarchy:', error);
            }
        }

        function drawTree(rootData) {
            const svg = document.getElementById('tree-svg');
            const svgRect = svg.getBoundingClientRect();
            const containerWidth = svgRect.width;

            // Clear existing content
            svg.innerHTML = '';

            // Calculate tree layout recursively
            const layoutTree = calculateTreeLayout(rootData, containerWidth);

            // Calculate total height needed
            const maxDepth = getMaxDepth(layoutTree);
            const height = Math.max(600, (maxDepth + 1) * LEVEL_HEIGHT + 100);

            // Set SVG dimensions to accommodate the full tree width
            const requiredWidth = Math.max(containerWidth, layoutTree.subtreeWidth + 100);
            svg.setAttribute('width', requiredWidth);
            svg.setAttribute('height', height);
            svg.setAttribute('viewBox', `0 0 ${requiredWidth} ${height}`);

            // Draw connections first (so they're behind nodes)
            drawConnectionsRecursive(svg, layoutTree);

            // Draw nodes on top
            drawNodesRecursive(svg, layoutTree);
        }

        function getMaxDepth(node, depth = 0) {
            if (!node.children || node.children.length === 0) {
                return depth;
            }
            return Math.max(...node.children.map(child => getMaxDepth(child, depth + 1)));
        }

        function calculateTreeLayout(node, containerWidth, depth = 0) {
            // First pass: calculate subtree widths bottom-up
            const treeWithWidths = calculateSubtreeWidths(node);

            // Second pass: assign x positions top-down
            const totalWidth = treeWithWidths.subtreeWidth;
            const startX = Math.max(BASE_NODE_RADIUS + 50, (containerWidth - totalWidth) / 2);

            assignPositions(treeWithWidths, startX, depth);

            return treeWithWidths;
        }

        function calculateSubtreeWidths(node) {
            const children = node.children || [];

            // Calculate dynamic radius for this node
            const nodeRadius = calculateNodeRadius(node.actorId);

            const layoutNode = {
                id: node.actorId,
                type: node.actorType,
                strategy: node.strategy,
                path: node.path,
                radius: nodeRadius, // Store calculated radius
                children: [],
                subtreeWidth: MIN_HORIZONTAL_SPACING
            };

            if (children.length === 0) {
                // Leaf node: minimum width based on node size
                layoutNode.subtreeWidth = Math.max(MIN_HORIZONTAL_SPACING, nodeRadius * 2 + 40);
                return layoutNode;
            }

            // Recursively calculate children's widths
            const childLayouts = children.map(child => calculateSubtreeWidths(child));
            layoutNode.children = childLayouts;

            // This node's subtree width is the sum of all children's subtree widths
            const totalChildrenWidth = childLayouts.reduce((sum, child) => sum + child.subtreeWidth, 0);
            layoutNode.subtreeWidth = Math.max(MIN_HORIZONTAL_SPACING, totalChildrenWidth, nodeRadius * 2 + 40);

            return layoutNode;
        }

        function assignPositions(node, x, depth) {
            const y = 80 + depth * LEVEL_HEIGHT;

            // Assign position to this node
            node.depth = depth;
            node.y = y;

            if (node.children.length === 0) {
                // Leaf node: position at x
                node.x = x + MIN_HORIZONTAL_SPACING / 2;
                return;
            }

            // Calculate positions for children
            let currentX = x;
            node.children.forEach(child => {
                assignPositions(child, currentX, depth + 1);
                currentX += child.subtreeWidth;
            });

            // Position parent centered above children
            if (node.children.length === 1) {
                node.x = node.children[0].x;
            } else {
                const firstChildX = node.children[0].x;
                const lastChildX = node.children[node.children.length - 1].x;
                node.x = (firstChildX + lastChildX) / 2;
            }
        }

        function drawConnectionsRecursive(svg, node) {
            if (!node.children || node.children.length === 0) {
                return;
            }

            node.children.forEach(child => {
                drawConnection(svg, node, child);
                drawConnectionsRecursive(svg, child);
            });
        }

        function drawConnection(svg, parent, child) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');

            // Curved line from parent to child using dynamic radii
            const d = `M ${parent.x} ${parent.y + parent.radius}
                       Q ${parent.x} ${(parent.y + child.y) / 2}
                         ${child.x} ${child.y - child.radius}`;

            line.setAttribute('d', d);
            line.setAttribute('class', 'connection-line');
            svg.appendChild(line);
        }

        function drawNodesRecursive(svg, node) {
            drawNode(svg, node);

            if (node.children && node.children.length > 0) {
                node.children.forEach(child => drawNodesRecursive(svg, child));
            }
        }

        function drawNode(svg, node) {
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('class', 'actor-node');
            group.setAttribute('data-actor-id', node.id);
            group.setAttribute('data-actor-type', node.type);

            // Circle with dynamic radius
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', node.x);
            circle.setAttribute('cy', node.y);
            circle.setAttribute('r', node.radius); // Use calculated radius
            circle.setAttribute('class', 'actor-circle');

            if (node.type === 'supervisor') {
                circle.setAttribute('fill', '#4CAE50');
                circle.setAttribute('stroke', '#45a049');
            } else {
                circle.setAttribute('fill', '#66BB6A');
                circle.setAttribute('stroke', '#4CAE50');
            }
            circle.setAttribute('stroke-width', 2);

            // Text (full ID, no truncation)
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', node.x);
            text.setAttribute('y', node.y + 5);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('class', 'actor-text');
            text.setAttribute('fill', 'white');
            text.textContent = node.id; // Display full ID

            group.appendChild(circle);
            group.appendChild(text);

            // Add event listeners
            group.addEventListener('mouseenter', (e) => showHoverCard(e, node));
            group.addEventListener('mouseleave', hideHoverCard);

            svg.appendChild(group);
        }

        function showHoverCard(event, node) {
            // Clear any pending hide timeout
            if (hideCardTimeout) {
                clearTimeout(hideCardTimeout);
                hideCardTimeout = null;
            }

            const card = document.getElementById('hoverCard');
            const svgRect = document.getElementById('tree-svg').getBoundingClientRect();
            const group = event.currentTarget;
            const circle = group.querySelector('circle');
            const cx = parseFloat(circle.getAttribute('cx'));
            const cy = parseFloat(circle.getAttribute('cy'));

            let html = `<h3>${node.type === 'supervisor' ? '🎭' : '👷'} ${node.id}</h3>`;

            html += `<div class="info-row">
                        <span class="info-label">Type:</span>
                        <span class="info-value">${node.type}</span>
                    </div>`;

            if (node.strategy) {
                html += `<div class="info-row">
                            <span class="info-label">Strategy:</span>
                            <span class="info-value badge">${node.strategy}</span>
                        </div>`;
            }

            if (node.path) {
                html += `<div class="info-row" style="font-size: 0.75em; color: #666; margin-top: 5px;">
                            ${node.path}
                        </div>`;
            }

            html += '<div class="actions">';

            // All actors can spawn children - pass node type and path
            html += `<button class="btn-primary" onclick="showAddWorkerModal('${node.id}', '${node.type}', '${node.path || ''}')">➕ Add Child</button>`;

            // Only workers can process work and fail
            if (node.type === 'worker') {
                html += `<button class="btn-success" onclick="sendWork('${node.id}')">📬 Send Work</button>`;
                html += `<button class="btn-warning" onclick="triggerFailure('${node.id}')">💥 Trigger Failure</button>`;
            }

            // Only workers can be stopped (don't stop the root supervisor)
            if (node.type === 'worker') {
                html += `<button class="btn-danger" onclick="stopWorker('${node.id}')">🛑 Stop</button>`;
            }

            html += '</div>';

            card.innerHTML = html;
            card.classList.add('active');

            // Position the card using the node's dynamic radius
            const nodeRadius = parseFloat(circle.getAttribute('r'));
            const cardWidth = 250;
            const cardLeft = cx + nodeRadius + 10;
            const cardTop = cy - 50;

            card.style.left = cardLeft + 'px';
            card.style.top = cardTop + 'px';

            // Add event listeners to the card itself to keep it visible when hovering
            card.addEventListener('mouseenter', cancelHideCard);
            card.addEventListener('mouseleave', scheduleHideCard);
        }

        function hideHoverCard() {
            scheduleHideCard();
        }

        function scheduleHideCard() {
            // Clear any existing timeout
            if (hideCardTimeout) {
                clearTimeout(hideCardTimeout);
            }

            // Schedule hide after a short delay (200ms)
            hideCardTimeout = setTimeout(() => {
                const card = document.getElementById('hoverCard');
                card.classList.remove('active');
                card.removeEventListener('mouseenter', cancelHideCard);
                card.removeEventListener('mouseleave', scheduleHideCard);
                hideCardTimeout = null;
            }, 200);
        }

        function cancelHideCard() {
            if (hideCardTimeout) {
                clearTimeout(hideCardTimeout);
                hideCardTimeout = null;
            }
        }

        // Generate a random short ID (e.g., "abc123")
        function generateRandomId() {
            const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
            let id = '';
            for (let i = 0; i < 6; i++) {
                id += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return id;
        }

        function showAddWorkerModal(parentId, parentType, parentPath) {
            document.getElementById('parentActorId').value = parentId || currentSupervisorId;
            document.getElementById('parentActorType').value = parentType || 'supervisor';
            document.getElementById('parentActorPath').value = parentPath || '';
            document.getElementById('addWorkerModal').classList.add('active');
            document.getElementById('strategySelect').focus();
            hideHoverCard();
        }

        function closeModal() {
            document.getElementById('addWorkerModal').classList.remove('active');
        }

        async function confirmAddWorker() {
            const parentId = document.getElementById('parentActorId').value;
            const parentType = document.getElementById('parentActorType').value;
            const parentPath = document.getElementById('parentActorPath').value;
            const strategy = document.getElementById('strategySelect').value;

            // Generate a random worker ID
            const childId = generateRandomId();

            try {
                const response = await fetch(`/api/actors/${parentId}/children`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        childId: childId,
                        strategy: strategy,
                        parentType: parentType,
                        parentPath: parentPath
                    })
                });

                const result = await response.json();
                if (result.success) {
                    closeModal();
                    refreshHierarchy();
                } else {
                    alert(result.message);
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        async function sendWork(workerId) {
            const taskName = prompt('Enter task name:', `task-${Date.now()}`);
            if (!taskName) return;

            hideHoverCard();

            try {
                const response = await fetch(`/api/workers/${workerId}/work`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        supervisorId: currentSupervisorId,
                        taskName: taskName
                    })
                });

                const result = await response.json();
                if (!result.success) {
                    alert(result.message);
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        async function triggerFailure(workerId) {
            hideHoverCard();

            try {
                const response = await fetch(`/api/workers/${workerId}/fail`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ supervisorId: currentSupervisorId })
                });

                const result = await response.json();
                if (!result.success) {
                    console.error('Trigger failure failed:', result.message);
                }
            } catch (error) {
                console.error('Error triggering failure:', error.message);
            }
        }

        async function stopWorker(workerId) {
            hideHoverCard();

            try {
                const response = await fetch(`/api/workers/${workerId}?supervisorId=${currentSupervisorId}`, {
                    method: 'DELETE'
                });

                const result = await response.json();
                if (result.success) {
                    refreshHierarchy();
                } else {
                    console.error('Stop worker failed:', result.message);
                }
            } catch (error) {
                console.error('Error stopping worker:', error.message);
            }
        }

        // Initialize
        initSSE();
        refreshHierarchy();
        setInterval(refreshHierarchy, 3000);

        // Close modal on ESC
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeModal();
                hideHoverCard();
            }
        });

        // Close modal on outside click
        document.getElementById('addWorkerModal').addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                closeModal();
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (hierarchyData) {
                drawTree(hierarchyData);
            }
        });
    </script>
</body>
</html>
