{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>Spring Boot Starter Actor is a library that integrates Spring Boot with the actor model using Pekko (an open-source, community-driven fork of Akka).</p>"},{"location":"#what-is-this-project-about","title":"What is this project about?","text":"<p>This project bridges the gap between Spring Boot and the actor model, allowing developers to integrate actors into their applications using familiar Spring Boot patterns with ease.</p>"},{"location":"#why","title":"Why?","text":"<p>Many developers use Java with Spring (usually Spring Boot). Modern programming guides recommend building stateless architectures. However, sometimes stateful features are needed, such as in chat applications where the server needs to know where clients in the same chatroom are located.</p> <p>The actor model is a well-known programming model suited for stateful applications:</p> <ul> <li>Encapsulate logic into actors</li> <li>Communicate by sending messages between them</li> </ul> <p>This project aims to bring together the best of both worlds:</p> <ul> <li>Spring Boot's ease of use and extensive ecosystem</li> <li>The actor model's natural approach to encapsulation and state management</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Auto-configure Pekko with Spring Boot</li> <li>Seamless integration with Spring's dependency injection</li> <li>Support for both local and cluster modes</li> <li>Easy actor creation and management</li> <li>Spring-friendly actor references</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Check out the Getting Started guide to begin using Spring Boot Starter Actor in your projects.</p>"},{"location":"#examples","title":"Examples","text":"<p>Explore our example applications to see Spring Boot Starter Actor in action:</p> <ul> <li>Simple Example: Demonstrates basic actor usage in a non-clustered environment</li> <li>Cluster Example: Shows how to use sharded actors in a clustered environment</li> <li>Chat Example: A complete chat application using actors</li> <li>Synchronization Example: Demonstrates synchronization patterns with actors</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you get started with Spring Boot Starter Actor in your Spring Boot application.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Java 11 or higher (Java 21+ recommended for virtual thread support)</li> <li>Spring Boot 2.x or 3.x</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Add the dependency to your project:</p>"},{"location":"getting-started/#gradle","title":"Gradle","text":"<pre><code>// Manually overwrite spring managed jackson dependency \ndependencyManagement {\n    imports {\n        // require minimum 2.17.3 version of jackson\n        mavenBom(\"com.fasterxml.jackson:jackson-bom:2.17.3\")\n    }\n}\n\n// Gradle(spring boot 2.7.x)\nimplementation 'io.github.seonwkim:spring-boot-starter-actor:0.3.0'\n\n// Gradle(spring boot 3.2.x)\nimplementation 'io.github.seonwkim:spring-boot-starter-actor_3:0.3.0'\n</code></pre>"},{"location":"getting-started/#maven","title":"Maven","text":"<pre><code>&lt;dependencyManagement&gt;\n  &lt;dependencies&gt;\n    &lt;!-- Override Spring Boot's jackson-bom with 2.17.3 --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;com.fasterxml.jackson&lt;/groupId&gt;\n      &lt;artifactId&gt;jackson-bom&lt;/artifactId&gt;\n      &lt;version&gt;2.17.3&lt;/version&gt;\n      &lt;type&gt;pom&lt;/type&gt;\n      &lt;scope&gt;import&lt;/scope&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n\n&lt;!-- Maven(spring boot 2.7.x) --&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;io.github.seonwkim&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter-actor&lt;/artifactId&gt;\n  &lt;version&gt;0.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;!-- Maven(spring boot 3.2.x) --&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;io.github.seonwkim&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter-actor_3&lt;/artifactId&gt;\n  &lt;version&gt;0.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>To view the latest versions, refer to the following: - spring-boot-starter-actor - spring-boot-starter-actor_3</p> <p>Note</p> <p>The library requires Jackson 2.17.3 or later. Ensure you override Spring Boot's managed Jackson dependency as shown above.</p>"},{"location":"getting-started/#basic-configuration","title":"Basic Configuration","text":"<p>Spring Boot Starter Actor uses Spring Boot's auto-configuration to set up the actor system. By default, it creates a local actor system with sensible defaults.</p>"},{"location":"getting-started/#enable-actor-support","title":"Enable Actor Support","text":"<p>Add the <code>@EnableActorSupport</code> annotation to your Spring Boot application class:</p> <pre><code>@SpringBootApplication\n@EnableActorSupport\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n</code></pre>"},{"location":"getting-started/#application-properties","title":"Application Properties","text":"<p>You can customize the actor system using application properties (or yaml):</p> <pre><code># application.properties or application.yml\nspring:\n  application:\n    name: spring-pekko\n  actor:\n    pekko:\n      actor:\n        provider: local\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have set up Spring Boot Starter Actor in your project, you can:</p> <ol> <li>Learn how to register actors and send messages</li> <li>Explore pub/sub topics for distributed messaging</li> <li>Create sharded actors for clustered environments</li> </ol>"},{"location":"examples/","title":"Spring Boot Starter Actor Examples","text":"<p>Welcome to the Spring Boot Starter Actor examples documentation. This documentation provides detailed explanations of the example projects included in the repository, demonstrating various features and use cases of the Spring Boot Starter Actor library.</p>"},{"location":"examples/#overview","title":"Overview","text":"<p>Spring Boot Starter Actor is a library that integrates the Apache Pekko (formerly Akka) actor model with Spring Boot, making it easy to use actors in your Spring applications. The actor model provides a powerful approach to building concurrent, distributed, and resilient applications.</p> <p>These examples demonstrate how to use Spring Boot Starter Actor in different scenarios, from simple applications to complex, real-world use cases.</p> <p>Learning Path</p> <p>Start with the Simple Example if you're new to the library, then progress through the other examples as you become more comfortable.</p>"},{"location":"examples/#available-examples","title":"Available Examples","text":""},{"location":"examples/#simple-example","title":"Simple Example","text":"<p>The Simple Example demonstrates the basic usage of Spring Boot Starter Actor in a non-clustered environment. It shows how to:</p> <ul> <li>Create and register actors in a Spring Boot application</li> <li>Send messages to actors and receive responses</li> <li>Integrate actors with a REST API</li> </ul> <p>Best for: Beginners learning the basics of the actor model and Spring Boot integration.</p>"},{"location":"examples/#cluster-example","title":"Cluster Example","text":"<p>The Cluster Example shows how to use Spring Boot Starter Actor in a clustered environment, focusing on sharded actors. It demonstrates:</p> <ul> <li>Creating and using sharded actors across a cluster</li> <li>Distributing actor instances across multiple nodes</li> <li>Sending messages to specific entity instances</li> <li>Handling entity state in a distributed environment</li> </ul> <p>Best for: Understanding distributed actor systems and cluster sharding.</p>"},{"location":"examples/#synchronization-example","title":"Synchronization Example","text":"<p>The Synchronization Example demonstrates how to implement efficient synchronization using Spring Boot Starter Actor, comparing it with traditional synchronization approaches. It shows:</p> <ul> <li>Implementing counters with different synchronization mechanisms</li> <li>Comparing database locking, Redis locking, and actor-based synchronization</li> <li>Handling concurrent access to shared resources</li> <li>Achieving high performance with actor-based synchronization</li> </ul> <p>This example explains why using actors for synchronization is cheap and efficient compared to other approaches.</p> <p>Best for: Understanding performance benefits of actor-based concurrency.</p>"},{"location":"examples/#chat-example","title":"Chat Example","text":"<p>The Chat Example demonstrates how to build a real-time chat application using Spring Boot Starter Actor with pub/sub topics. It shows:</p> <ul> <li>Building a real-time chat application using actors and pub/sub</li> <li>Implementing WebSocket communication for real-time messaging</li> <li>Creating a scalable, clustered chat system</li> <li>Eliminating the need for external message brokers or middleware</li> </ul> <p>This example demonstrates how Spring Boot Starter Actor can be used to build real-world applications efficiently without relying on additional infrastructure components.</p> <p>Best for: Building real-time applications with WebSockets and pub/sub.</p>"},{"location":"examples/#monitoring-example","title":"Monitoring Example","text":"<p>The Monitoring example demonstrates how to monitor and analyze your actor system's performance. It shows:</p> <ul> <li>Setting up a complete monitoring stack with Prometheus and Grafana</li> <li>Collecting and exporting metrics from your actor system</li> <li>Visualizing actor performance metrics in real-time</li> <li>Tracking message processing times and throughput</li> <li>Monitoring cluster health and resource usage</li> </ul> <p>This example provides insights into how Spring Boot Starter Actor can be used to observe and optimize your application's performance without complex configuration.</p> <p>Best for: Production monitoring and performance optimization.</p>"},{"location":"examples/#getting-started","title":"Getting Started","text":"<p>To run these examples:</p> <ol> <li>Clone the repository: <code>git clone https://github.com/seonwkim/spring-boot-starter-actor.git</code></li> <li>Navigate to the example directory you want to run: <code>cd example/&lt;example-name&gt;</code></li> <li>Follow the instructions in the corresponding documentation file</li> </ol> <p>Running Examples</p> <p>Each example includes a README with specific instructions for building and running the application.</p>"},{"location":"examples/#additional-resources","title":"Additional Resources","text":"<ul> <li>Spring Boot Starter Actor Documentation</li> <li>GitHub Repository</li> </ul>"},{"location":"examples/chat/","title":"Chat Example","text":"<p>This guide demonstrates how to build a real-time chat application using Spring Boot Starter Actor's pub/sub topics without introducing third-party middleware.</p>"},{"location":"examples/chat/#overview","title":"Overview","text":"<p>The chat example shows how to:</p> <ul> <li>Build a real-time chat application using actors and pub/sub topics</li> <li>Implement WebSocket communication for real-time messaging</li> <li>Create a scalable, clustered chat system using distributed pub/sub</li> <li>Eliminate the need for external message brokers or middleware</li> </ul> <p>This example demonstrates how Spring Boot Starter Actor can be used to build real-world applications efficiently without relying on additional infrastructure components.</p> <p>No External Dependencies</p> <p>No Redis, RabbitMQ, or Kafka required! The actor system provides everything needed for distributed messaging.</p>"},{"location":"examples/chat/#source-code","title":"Source Code","text":"<p>You can find the complete source code for this example on GitHub:</p> <p>Chat Example Source Code</p> <p>Real-World Application</p> <p>This example demonstrates patterns applicable to many real-time applications beyond chat.</p>"},{"location":"examples/chat/#key-components","title":"Key Components","text":""},{"location":"examples/chat/#chatroomactor-with-pubsub","title":"ChatRoomActor with Pub/Sub","text":"<p><code>ChatRoomActor</code> is a sharded actor that manages a chat room using pub/sub topics. Each chat room creates a topic for message distribution, and users subscribe to receive messages. This eliminates the need to maintain a list of user actor references:</p> <pre><code>@Component\npublic class ChatRoomActor implements SpringShardedActor&lt;ChatRoomActor.Command&gt; {\n\n    public static final EntityTypeKey&lt;Command&gt; TYPE_KEY =\n            EntityTypeKey.create(Command.class, \"ChatRoomActor\");\n\n    /** Base interface for all commands that can be sent to the chat room actor. */\n    public interface Command extends JsonSerializable {}\n\n    /** Command to join a chat room. Provides actor ref for subscription. */\n    public static class JoinRoom implements Command {\n        public final String userId;\n        public final ActorRef&lt;UserActor.Command&gt; userActorRef;\n\n        public JoinRoom(String userId, ActorRef&lt;UserActor.Command&gt; userActorRef) {\n            this.userId = userId;\n            this.userActorRef = userActorRef;\n        }\n    }\n\n   /** Command to leave a chat room. */\n   public static class LeaveRoom implements Command {\n      public final String userId;\n\n      public LeaveRoom( String userId) {\n         this.userId = userId;\n      }\n   }\n\n   /** Command to send a message to the chat room. */\n   public static class SendMessage implements Command {\n      public final String userId;\n      public final String message;\n\n      public SendMessage(String userId, String message) {\n         this.userId = userId;\n         this.message = message;\n      }\n   }\n\n   @Override\n   public EntityTypeKey&lt;Command&gt; typeKey() {\n      return TYPE_KEY;\n   }\n\n   @Override\n    public SpringShardedActorBehavior&lt;Command&gt; create(SpringShardedActorContext&lt;Command&gt; ctx) {\n        final String roomId = ctx.getEntityId();\n\n        return SpringShardedActorBehavior.builder(Command.class, ctx)\n                .withState(behaviorCtx -&gt; new ChatRoomBehavior(behaviorCtx, roomId))\n                .onMessage(JoinRoom.class, ChatRoomBehavior::onJoinRoom)\n                .onMessage(LeaveRoom.class, ChatRoomBehavior::onLeaveRoom)\n                .onMessage(SendMessage.class, ChatRoomBehavior::onSendMessage)\n                .build();\n    }\n\n    /**\n     * Behavior handler for chat room actor using pub/sub.\n     * Creates a topic for the room and publishes events to subscribers.\n     *\n     * Note: Since this is a sharded actor that doesn't easily support Spring DI,\n     * we use TopicSpawner directly. For regular actors, use SpringTopicManager\n     * with dependency injection instead.\n     */\n    private static class ChatRoomBehavior {\n        private final SpringBehaviorContext&lt;Command&gt; ctx;\n        private final String roomId;\n        private final SpringTopicRef&lt;UserActor.Command&gt; roomTopic;\n        private final Map&lt;String, SpringActorHandle&lt;UserActor.Command&gt;&gt; connectedUsers =\n                new HashMap&lt;&gt;();\n\n        ChatRoomBehavior(SpringBehaviorContext&lt;Command&gt; ctx, String roomId) {\n            this.ctx = ctx;\n            this.roomId = roomId;\n            // Create a pub/sub topic for this chat room using TopicSpawner directly\n            // For actors with DI support, use SpringTopicManager instead\n            this.roomTopic = TopicSpawner.createTopic(\n                ctx.getUnderlying(),\n                UserActor.Command.class,\n                \"chat-room-\" + roomId\n            );\n            ctx.getLog().info(\"Created pub/sub topic for chat room: {}\", roomId);\n        }\n\n        /**\n         * Handles JoinRoom commands by subscribing the user to the room topic.\n         */\n        private Behavior&lt;Command&gt; onJoinRoom(JoinRoom msg) {\n            // Wrap the Pekko ActorRef in SpringActorHandle for subscription\n            SpringActorHandle&lt;UserActor.Command&gt; springUserRef =\n                new SpringActorHandle&lt;&gt;(\n                    ctx.getUnderlying().getSystem().scheduler(),\n                    msg.userActorRef);\n\n            // Track the user ref for unsubscription\n            connectedUsers.put(msg.userId, springUserRef);\n\n            // Subscribe the user to the room topic\n            roomTopic.subscribe(springUserRef);\n\n            ctx.getLog().info(\"User {} joined room {} (now {} users)\",\n                msg.userId, roomId, connectedUsers.size());\n\n            // Notify all users that a new user has joined\n            UserActor.JoinRoomEvent joinRoomEvent = new UserActor.JoinRoomEvent(msg.userId);\n            roomTopic.publish(joinRoomEvent);\n\n            return Behaviors.same();\n        }\n\n        /**\n         * Handles LeaveRoom commands by unsubscribing the user from the room topic.\n         */\n        private Behavior&lt;Command&gt; onLeaveRoom(LeaveRoom msg) {\n            // Remove the user and get their ref for unsubscription\n            SpringActorHandle&lt;UserActor.Command&gt; userRef = connectedUsers.remove(msg.userId);\n\n            if (userRef != null) {\n                // Unsubscribe the user from the topic\n                roomTopic.unsubscribe(userRef);\n\n                ctx.getLog().info(\"User {} left room {} ({} users remaining)\",\n                    msg.userId, roomId, connectedUsers.size());\n\n                // Notify all remaining users that a user has left\n                UserActor.LeaveRoomEvent leaveRoomEvent = new UserActor.LeaveRoomEvent(msg.userId);\n                roomTopic.publish(leaveRoomEvent);\n            }\n\n            return Behaviors.same();\n        }\n\n        /**\n         * Handles SendMessage commands by publishing the message to the room topic.\n         */\n        private Behavior&lt;Command&gt; onSendMessage(SendMessage msg) {\n            ctx.getLog().debug(\"Broadcasting message from {} in room {}\", msg.userId, roomId);\n\n            // Create a message event\n            UserActor.SendMessageEvent messageEvent =\n                new UserActor.SendMessageEvent(msg.userId, msg.message);\n\n            // Publish the message to all subscribers via the topic\n            roomTopic.publish(messageEvent);\n\n            return Behaviors.same();\n        }\n    }\n}\n</code></pre>"},{"location":"examples/chat/#useractor","title":"UserActor","text":"<p><code>UserActor</code> represents a connected user. It subscribes to chat room topics and sends messages to the user's WebSocket connection:</p> <pre><code>@Component\npublic class UserActor implements SpringActorWithContext&lt;\n    UserActor.Command, UserActor.UserActorContext&gt; {\n\n    public interface Command extends JsonSerializable {}\n\n    // Command and event classes...\n\n    @Override\n    public SpringActorBehavior&lt;Command&gt; create(UserActorContext actorContext) {\n        return SpringActorBehavior.builder(Command.class, actorContext)\n                .withState(ctx -&gt; new UserActorBehavior(\n                        ctx, actorContext.actorSystem, actorContext.userId,\n                        actorContext.messageSink))\n                .onMessage(Connect.class, UserActorBehavior::onConnect)\n                .onMessage(JoinRoom.class, UserActorBehavior::onJoinRoom)\n                .onMessage(LeaveRoom.class, UserActorBehavior::onLeaveRoom)\n                .onMessage(SendMessage.class, UserActorBehavior::onSendMessage)\n                .onMessage(JoinRoomEvent.class, UserActorBehavior::onJoinRoomEvent)\n                .onMessage(LeaveRoomEvent.class, UserActorBehavior::onLeaveRoomEvent)\n                .onMessage(SendMessageEvent.class, UserActorBehavior::onSendMessageEvent)\n                .build();\n    }\n\n    public static class UserActorBehavior {\n        private final SpringBehaviorContext&lt;Command&gt; context;\n        private final SpringActorSystem actorSystem;\n        private final String userId;\n        private final Sinks.Many&lt;String&gt; messageSink;\n\n        @Nullable private String currentRoomId;\n\n        // When joining a room, send the raw Pekko ActorRef (serializable)\n        private Behavior&lt;Command&gt; onJoinRoom(JoinRoom command) {\n            currentRoomId = command.roomId;\n            final var roomActor = getRoomActor();\n            sendEvent(\"joined\", json -&gt; {\n                json.append(\",\\\"roomId\\\":\\\"\").append(escapeJson(currentRoomId)).append(\"\\\"\");\n            });\n\n            // Send raw ActorRef for cluster serialization\n            roomActor.tell(new ChatRoomActor.JoinRoom(\n                userId,\n                context.getUnderlying().getSelf()));\n            return Behaviors.same();\n        }\n\n        // Event handlers receive messages via pub/sub topic\n        private Behavior&lt;Command&gt; onJoinRoomEvent(JoinRoomEvent event) {\n            sendEvent(\"user_joined\", json -&gt; {\n                json.append(\",\\\"userId\\\":\\\"\").append(escapeJson(event.userId)).append(\"\\\"\");\n                json.append(\",\\\"roomId\\\":\\\"\").append(escapeJson(currentRoomId)).append(\"\\\"\");\n            });\n            return Behaviors.same();\n        }\n\n        private Behavior&lt;Command&gt; onSendMessageEvent(SendMessageEvent event) {\n            sendEvent(\"message\", json -&gt; {\n                json.append(\",\\\"userId\\\":\\\"\").append(escapeJson(event.userId)).append(\"\\\"\");\n                json.append(\",\\\"message\\\":\\\"\").append(escapeJson(event.message)).append(\"\\\"\");\n                json.append(\",\\\"roomId\\\":\\\"\").append(escapeJson(currentRoomId)).append(\"\\\"\");\n            });\n            return Behaviors.same();\n        }\n\n        private SpringShardedActorHandle&lt;ChatRoomActor.Command&gt; getRoomActor() {\n            return actorSystem\n                    .sharded(ChatRoomActor.class)\n                    .withId(currentRoomId)\n                    .get();\n        }\n    }\n}\n</code></pre>"},{"location":"examples/chat/#architecture-with-pubsub","title":"Architecture with Pub/Sub","text":""},{"location":"examples/chat/#benefits-of-pubsub-approach","title":"Benefits of Pub/Sub Approach","text":"<p>The pub/sub implementation provides several advantages:</p> <ol> <li>Simplified State Management - No need to maintain a list of user actor references</li> <li>Automatic Cleanup - Users are automatically unsubscribed when their actors terminate</li> <li>Scalability - Topics work seamlessly across cluster nodes</li> <li>Decoupled Communication - Publishers don't need to know about subscribers</li> <li>Location Transparency - Works the same whether actors are local or distributed</li> </ol> <p>Pub/Sub vs Direct Messaging</p> <p>Pub/sub is ideal for one-to-many communication patterns. For point-to-point messaging, use direct actor references instead.</p>"},{"location":"examples/chat/#message-flow","title":"Message Flow","text":"<pre><code>1. User connects \u2192 UserActor created\n2. User joins room \u2192 UserActor tells ChatRoomActor\n3. ChatRoomActor subscribes UserActor to room topic\n4. User sends message \u2192 ChatRoomActor publishes to topic\n5. All subscribed UserActors receive message via topic\n6. UserActors forward to WebSocket clients\n</code></pre>"},{"location":"examples/chat/#cluster-serialization","title":"Cluster Serialization","text":"<p>Important: When sending actor references across cluster boundaries, use raw Pekko <code>ActorRef</code> instead of <code>SpringActorHandle</code>:</p> <pre><code>// \u2705 Correct: Raw ActorRef is serializable\nroomActor.tell(new ChatRoomActor.JoinRoom(userId, context.getUnderlying().getSelf()));\n\n// \u274c Wrong: SpringActorHandle contains non-serializable Scheduler\nroomActor.tell(new ChatRoomActor.JoinRoom(userId, context.getSelf()));\n</code></pre> <p>Serialization</p> <p><code>SpringActorHandle</code> is a local convenience wrapper that contains a non-serializable scheduler. For cluster messages, always use the raw Pekko <code>ActorRef</code> from <code>context.getUnderlying().getSelf()</code>.</p>"},{"location":"examples/chat/#running-the-application","title":"Running the Application","text":""},{"location":"examples/chat/#local-cluster-setup","title":"Local Cluster Setup","text":"<p>You can run multiple instances of the application locally using Gradle:</p> <pre><code># Run the server app \nsh cluster-start.sh chat io.github.seonwkim.example.SpringPekkoApplication 8080 2551 3\n\n# Run the frontend app  \ncd example/chat/frontend \nnpm run dev \n</code></pre>"},{"location":"examples/chat/#architecture-benefits","title":"Architecture Benefits","text":"<p>This architecture eliminates the need for third-party middleware by leveraging:</p> <ul> <li>Distributed pub/sub topics for message distribution</li> <li>Sharded actors for scalability and fault tolerance</li> <li>Built-in message routing between actors</li> <li>Natural state management within actors</li> <li>Real-time communication via WebSockets</li> <li>Automatic cleanup and lifecycle management</li> </ul> <p>Production Ready</p> <p>This architecture is production-ready and can scale to thousands of concurrent users across multiple nodes.</p>"},{"location":"examples/chat/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Pub/sub topics provide a clean abstraction for one-to-many communication</li> <li>The actor model combined with pub/sub creates an efficient, scalable messaging system</li> <li>WebSockets and actors work together seamlessly for real-time applications</li> <li>No external message broker required - everything is built into the framework</li> <li>Cluster-aware topics distribute messages automatically across nodes</li> </ul>"},{"location":"examples/chat/#next-steps","title":"Next Steps","text":"<ul> <li>Pub/Sub Topics Guide - Deep dive into pub/sub concepts</li> <li>Cluster Example - Learn about cluster sharding</li> </ul>"},{"location":"examples/cluster/","title":"Cluster Example","text":"<p>This guide demonstrates how to use Spring Boot Starter Actor in a clustered environment, focusing on sharded actors.</p>"},{"location":"examples/cluster/#overview","title":"Overview","text":"<p>The cluster example shows how to:</p> <ul> <li>Create and use sharded actors across a cluster</li> <li>Distribute actor instances across multiple nodes</li> <li>Send messages to specific entity instances</li> <li>Handle entity state in a distributed environment</li> </ul> <p>This example demonstrates the power of the actor model for building scalable, distributed applications with Spring Boot.</p> <p>Cluster Sharding</p> <p>Cluster sharding automatically distributes entities across nodes and provides location transparency for messaging.</p>"},{"location":"examples/cluster/#source-code","title":"Source Code","text":"<p>You can find the complete source code for this example on GitHub:</p> <p>Cluster Example Source Code</p> <p>Prerequisites</p> <p>Familiarity with the Simple Example is recommended before diving into cluster concepts.</p>"},{"location":"examples/cluster/#key-components","title":"Key Components","text":""},{"location":"examples/cluster/#helloactor","title":"HelloActor","text":"<p><code>HelloActor</code> is a sharded actor that responds to messages in a clustered environment. Each entity is a separate instance identified by an entity ID. The actor demonstrates:</p> <ul> <li>How to implement the <code>SpringShardedActor</code> interface</li> <li>How to define serializable message types for cluster communication</li> <li>How to create entity behaviors</li> <li>How to handle messages in a clustered environment</li> </ul> <pre><code>@Component\npublic class HelloActor implements SpringShardedActor&lt;HelloActor.Command&gt; {\n    public static final EntityTypeKey&lt;Command&gt; TYPE_KEY =\n            EntityTypeKey.create(Command.class, \"HelloActor\");\n\n    // Command interface and message types\n    public interface Command extends JsonSerializable {}\n\n    public static class SayHello extends AskCommand&lt;String&gt; implements Command {\n        public final String message;\n\n        public SayHello(String message) {\n            this.message = message;\n        }\n    }\n\n    @Override\n    public EntityTypeKey&lt;Command&gt; typeKey() {\n        return TYPE_KEY;\n    }\n\n    @Override\n    public SpringShardedActorBehavior&lt;Command&gt; create(SpringShardedActorContext&lt;Command&gt; ctx) {\n        final String entityId = ctx.getEntityId();\n\n        return SpringShardedActorBehavior.builder(Command.class, ctx)\n                .withState(actorCtx -&gt; new HelloActorBehavior(actorCtx, entityId))\n                .onMessage(SayHello.class, HelloActorBehavior::onSayHello)\n                .build();\n    }\n\n    /**\n     * Behavior handler for hello actor. Holds the entity ID and handles messages.\n     */\n    private static class HelloActorBehavior {\n        private final ActorContext&lt;Command&gt; ctx;\n        private final String entityId;\n\n        HelloActorBehavior(ActorContext&lt;Command&gt; ctx, String entityId) {\n            this.ctx = ctx;\n            this.entityId = entityId;\n        }\n\n        /**\n         * Handles SayHello commands by responding with node and entity information.\n         */\n        private Behavior&lt;Command&gt; onSayHello(SayHello msg) {\n            // Get information about the current node and entity\n            final String nodeAddress = ctx.getSystem().address().toString();\n\n            // Create a response message with node and entity information\n            final String message = \"Received from entity [\" + entityId + \"] on node [\" + nodeAddress + \"]\";\n\n            // Send the response back to the caller\n            msg.reply(message);\n\n            return Behaviors.same();\n        }\n    }\n\n    @Override\n    public ShardingMessageExtractor&lt;ShardEnvelope&lt;Command&gt;, Command&gt; extractor() {\n        return new DefaultShardingMessageExtractor&lt;&gt;(3);\n    }\n}\n</code></pre>"},{"location":"examples/cluster/#helloservice","title":"HelloService","text":"<p><code>HelloService</code> acts as an intermediary between the REST API and the actor system:</p> <ul> <li>It gets references to actor entities using the sharded method</li> <li>It provides methods to send messages to specific entities and return the responses</li> <li>It converts actor responses to reactive Mono objects for use with Spring WebFlux</li> </ul> <pre><code>@Service\npublic class HelloService {\n    private final SpringActorSystem springActorSystem;\n\n    public HelloService(SpringActorSystem springActorSystem) {\n        this.springActorSystem = springActorSystem;\n    }\n\n    public Mono&lt;String&gt; hello(String message, String entityId) {\n        // Get a reference to the actor entity\n        SpringShardedActorHandle&lt;HelloActor.Command&gt; actorRef =\n                springActorSystem.sharded(HelloActor.class).withId(entityId).get();\n\n        // Send the message to the actor and get the response\n        CompletionStage&lt;String&gt; response = actorRef\n                .ask(new HelloActor.SayHello(message))\n                .withTimeout(Duration.ofSeconds(3))\n                .execute();\n\n        // Convert the CompletionStage to a Mono for reactive programming\n        return Mono.fromCompletionStage(response);\n    }\n}\n</code></pre>"},{"location":"examples/cluster/#hellocontroller","title":"HelloController","text":"<p><code>HelloController</code> exposes the actor functionality via a REST API:</p> <ul> <li>It injects the HelloService</li> <li>It defines REST endpoints that call the service methods with entity IDs</li> <li>It returns the actor responses as HTTP responses</li> </ul> <pre><code>@RestController\npublic class HelloController {\n    private final HelloService helloService;\n\n    public HelloController(HelloService helloService) {\n        this.helloService = helloService;\n    }\n\n    @GetMapping(\"/hello\")\n    public Mono&lt;String&gt; hello(@RequestParam String message, @RequestParam String entityId) {\n        return helloService.hello(message, entityId);\n    }\n}\n</code></pre>"},{"location":"examples/cluster/#configuration","title":"Configuration","text":"<p>The cluster example requires additional configuration to set up the actor cluster:</p> <pre><code>spring:\n  application:\n    name: spring-pekko\n  actor:\n    pekko:\n      name: spring-pekko-example\n      actor:\n        provider: cluster\n        allow-java-serialization: off\n        warn-about-java-serializer-usage: on\n      remote:\n        artery:\n          canonical:\n            hostname: 127.0.0.1\n            port: 2551\n      cluster:\n        name: spring-pekko-example\n        seed-nodes:\n          - pekko://spring-pekko-example@127.0.0.1:2551\n          - pekko://spring-pekko-example@127.0.0.1:2552\n          - pekko://spring-pekko-example@127.0.0.1:2553\n        downing-provider-class: org.apache.pekko.cluster.sbr.SplitBrainResolverProvider\n\nserver:\n  port: 8080\n</code></pre> <p>Serialization</p> <p>Java serialization is disabled for security and performance. Always use <code>JsonSerializable</code> or <code>CborSerializable</code> for cluster messages.</p>"},{"location":"examples/cluster/#running-the-example","title":"Running the Example","text":"<p>To run the cluster example:</p> <ol> <li> <p>Start multiple instances with different ports: <pre><code>sh cluster-start.sh cluster io.github.seonwkim.example.SpringPekkoApplication 8080 2551 3\n</code></pre></p> </li> <li> <p>Send messages to test entity distribution: <pre><code># Try different entity IDs to see distribution\ncurl \"http://localhost:8080/hello?message=test&amp;entityId=entity-1\"\ncurl \"http://localhost:8081/hello?message=test&amp;entityId=entity-2\"\ncurl \"http://localhost:8082/hello?message=test&amp;entityId=entity-3\"\n</code></pre></p> </li> <li> <p>Observe behavior:</p> </li> <li>The same entity ID always routes to the same node</li> <li>Different entity IDs are distributed across the cluster</li> <li>Try sending the same entity ID to different nodes to verify routing</li> </ol> <p>Entity Affinity</p> <p>Notice that regardless of which node receives the HTTP request, messages for the same entity ID always go to the same actor instance in the cluster.</p>"},{"location":"examples/cluster/#entity-benefits","title":"Entity Benefits","text":"<p>Entities in Spring Boot Starter Actor provide:</p> <ul> <li>Automatic distribution across the cluster</li> <li>Location transparency for messaging - send messages without knowing which node hosts the entity</li> <li>Scalability with cluster expansion - add nodes to increase capacity</li> <li>Fault tolerance with automatic recreation - entities restart on different nodes if a node fails</li> <li>Simplified state management - each entity maintains its own isolated state</li> </ul> <p>Scalability</p> <p>Simply add more nodes to the cluster to increase capacity. The system automatically rebalances entities across all nodes.</p>"},{"location":"examples/cluster/#next-steps","title":"Next Steps","text":"<ul> <li>Sharded Actors Guide - Deep dive into cluster sharding concepts</li> <li>Chat Example - Build a distributed real-time chat application</li> <li>Synchronization Example - Compare actor-based vs traditional synchronization</li> </ul>"},{"location":"examples/monitoring/","title":"Monitoring","text":"<p>This guide demonstrates how to set up and use the built-in monitoring capabilities of Spring Boot Starter Actor to observe and analyze your actor system's performance.</p>"},{"location":"examples/monitoring/#overview","title":"Overview","text":"<p>The monitoring example shows how to:</p> <ul> <li>Set up a complete monitoring stack with Prometheus and Grafana</li> <li>Collect and export metrics from your actor system</li> <li>Visualize actor performance metrics in real-time</li> <li>Track message processing times and throughput</li> <li>Monitor cluster health and resource usage</li> </ul> <p>This example provides insights into how Spring Boot Starter Actor can be used to observe and optimize your application's performance without complex configuration.</p> <p>Complete Monitoring Stack</p> <p>The example includes a pre-configured Prometheus + Grafana stack ready to use with Docker Compose.</p>"},{"location":"examples/monitoring/#key-components","title":"Key Components","text":""},{"location":"examples/monitoring/#metrics-module","title":"Metrics Module","text":"<p>The Metrics module provides instrumentation for Pekko actors to collect performance metrics. It uses a Java agent to intercept method calls and capture timing information.</p> <pre><code># Include the Java agent when starting your application\njava -javaagent:metrics-{version}-agent.jar -jar your-application.jar\n</code></pre> <p>Java Agent Required</p> <p>The metrics module requires running with the Java agent to collect actor performance metrics.</p>"},{"location":"examples/monitoring/#actorinstrumentationeventlistener","title":"ActorInstrumentationEventListener","text":"<p>The <code>ActorInstrumentationEventListener</code> allows you to capture metrics about actor message processing:</p> <pre><code>// Register a listener for actor messages\nActorInstrumentationEventListener.register(new InvokeAdviceEventListener() {\n    @Override\n    public void onEnter(Envelope envelope) {\n        // Called when a message is about to be processed\n    }\n\n    @Override\n    public void onExit(Envelope envelope, long startTime, Throwable throwable) {\n        // Called when message processing is complete\n        // Calculate duration: System.nanoTime() - startTime\n    }\n});\n</code></pre>"},{"location":"examples/monitoring/#metrics-exporter","title":"Metrics Exporter","text":"<p>The <code>ActorClusterMetricsExporter</code> shows how to export metrics to Prometheus via Micrometer:</p> <pre><code>@Component\npublic class ActorClusterMetricsExporter {\n    private final MeterRegistry registry;\n    private final ConcurrentHashMap&lt;String, Timer&gt; invokeTimers = new ConcurrentHashMap&lt;&gt;();\n    private final ConcurrentHashMap&lt;String, Counter&gt; invokeCounters = new ConcurrentHashMap&lt;&gt;();\n\n    // Define which message types to track\n    private final Set&lt;Class&lt;?&gt;&gt; targetClasses = Set.of(\n        ChatRoomActor.JoinRoom.class,\n        ChatRoomActor.LeaveRoom.class,\n        ChatRoomActor.SendMessage.class\n    );\n\n    public ActorClusterMetricsExporter(MeterRegistry registry) {\n        this.registry = registry;\n    }\n\n    @PostConstruct\n    public void registerMetrics() {\n        ActorInstrumentationEventListener.register(new InvokeAdviceEventListener() {\n            @Override\n            public void onEnter(Envelope envelope) {}\n\n            @Override\n            public void onExit(Envelope envelope, long startTime, Throwable throwable) {\n                if (!targetClasses.contains(envelope.message().getClass())) {\n                    return;\n                }\n\n                String messageType = envelope.message().getClass().getSimpleName();\n\n                // Record timing metrics\n                Timer timer = invokeTimers.computeIfAbsent(messageType, mt -&gt;\n                    Timer.builder(\"pekko.actorcell.invoke.timer\")\n                         .description(\"Time spent processing messages\")\n                         .tags(\"messageType\", mt)\n                         .register(registry)\n                );\n\n                // Record count metrics\n                Counter counter = invokeCounters.computeIfAbsent(messageType, mt -&gt;\n                    Counter.builder(\"pekko.actorcell.invoke.count\")\n                           .description(\"Count of messages processed\")\n                           .tags(\"messageType\", mt)\n                           .register(registry)\n                );\n\n                long duration = System.nanoTime() - startTime;\n                timer.record(duration, TimeUnit.NANOSECONDS);\n                counter.increment();\n            }\n        });\n    }\n}\n</code></pre>"},{"location":"examples/monitoring/#setting-up-the-monitoring-stack","title":"Setting Up the Monitoring Stack","text":"<p>Spring Boot Starter Actor includes a ready-to-use monitoring stack with Prometheus and Grafana, managed via Docker Compose.</p>"},{"location":"examples/monitoring/#1-start-the-monitoring-stack","title":"1. Start the Monitoring Stack","text":"<p>Navigate to the monitoring directory and start the stack:</p> <pre><code>cd scripts/monitoring\ndocker-compose up -d\n</code></pre> <p>This will start:</p> <ul> <li>Prometheus at <code>http://localhost:9090</code></li> <li>Grafana at <code>http://localhost:3000</code></li> </ul> <p>Default Credentials</p> <p>Grafana default credentials are <code>admin/admin</code>. You'll be prompted to change the password on first login.</p>"},{"location":"examples/monitoring/#2-configure-your-application","title":"2. Configure Your Application","text":"<p>Ensure your application exposes metrics via Spring Boot Actuator:</p> <pre><code># application.yaml\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,info,prometheus\n  metrics:\n    export:\n      prometheus:\n        enabled: true\n</code></pre>"},{"location":"examples/monitoring/#3-access-the-dashboards","title":"3. Access the Dashboards","text":"<p>Open Grafana at <code>http://localhost:3000</code> (default credentials: <code>admin/admin</code>) to view the pre-configured dashboards.</p> <p>Pre-Configured Dashboards</p> <p>The monitoring stack includes pre-built dashboards for actor metrics, showing message processing times, throughput, and more.</p>"},{"location":"examples/monitoring/#4-shutdown-when-done","title":"4. Shutdown When Done","text":"<pre><code>cd scripts/monitoring\ndocker-compose down -v\n</code></pre> <p>Data Persistence</p> <p>Using <code>-v</code> flag removes volumes, which deletes all metrics data. Omit <code>-v</code> if you want to preserve data between restarts.</p>"},{"location":"examples/monitoring/#summary","title":"Summary","text":"<ul> <li>Collect performance data with the metrics module and Java agent</li> <li>Visualize with Prometheus and Grafana using pre-configured dashboards</li> <li>Monitor actor performance including message processing times and throughput</li> <li>Track cluster health and resource usage across all nodes</li> </ul> <p>Production Monitoring</p> <p>This monitoring setup is production-ready and can be adapted to your specific infrastructure needs.</p>"},{"location":"examples/monitoring/#next-steps","title":"Next Steps","text":"<ul> <li>Chat Example - See monitoring in action with a real application</li> <li>Cluster Example - Monitor distributed actor systems</li> <li>Logging Guide - Add MDC logging for better observability</li> </ul>"},{"location":"examples/simple/","title":"Simple Example","text":"<p>This guide demonstrates the basic usage of Spring Boot Starter Actor in a simple, non-clustered environment.</p>"},{"location":"examples/simple/#overview","title":"Overview","text":"<p>The simple example shows how to:</p> <ul> <li>Create and register actors in a Spring Boot application</li> <li>Send messages to actors and receive responses</li> <li>Integrate actors with a REST API</li> <li>Use lifecycle hooks (PreStart, PreRestart, PostStop)</li> </ul> <p>This example is a great starting point for understanding the core concepts of the actor model and how Spring Boot Starter Actor makes it easy to use actors in your Spring applications.</p> <p>For Beginners</p> <p>Start here if you're new to the actor model or Spring Boot Starter Actor.</p>"},{"location":"examples/simple/#source-code","title":"Source Code","text":"<p>You can find the complete source code for this example on GitHub:</p> <p>Simple Example Source Code</p> <p>Example Structure</p> <p>The example includes actors, services, controllers, and configuration demonstrating best practices.</p>"},{"location":"examples/simple/#key-components","title":"Key Components","text":""},{"location":"examples/simple/#helloactor","title":"HelloActor","text":"<p><code>HelloActor</code> is a simple actor that responds to \"hello\" messages. It demonstrates:</p> <ul> <li>How to implement the <code>SpringActor</code> interface</li> <li>How to define message types (commands)</li> <li>How to create actor behaviors</li> <li>How to handle messages and send responses</li> <li>How to use lifecycle hooks: PreStart (called in <code>create()</code>), PreRestart and PostStop (using <code>onSignal</code>)</li> </ul> <pre><code>@Component\npublic class HelloActor implements SpringActor&lt;HelloActor.Command&gt; {\n    // Command interface and message types\n    public interface Command {}\n\n    public static class SayHello extends AskCommand&lt;String&gt; implements Command {\n        public SayHello() {}\n    }\n\n    @Override\n    public SpringActorBehavior&lt;Command&gt; create(SpringActorContext actorContext) {\n        return SpringActorBehavior.builder(Command.class, actorContext)\n                .withState(ctx -&gt; new HelloActorBehavior(ctx, actorContext))\n                .onMessage(SayHello.class, HelloActorBehavior::onSayHello)\n                .onMessage(TriggerFailure.class, HelloActorBehavior::onTriggerFailure)\n                .onSignal(PreRestart.class, HelloActorBehavior::onPreRestart)\n                .onSignal(PostStop.class, HelloActorBehavior::onPostStop)\n                .withSupervisionStrategy(SupervisorStrategy.restart()\n                        .withLimit(10, Duration.ofMinutes(1)))\n                .build();\n    }\n\n    // Actor behavior implementation\n    private static class HelloActorBehavior {\n        private final ActorContext&lt;Command&gt; ctx;\n        private final SpringActorContext actorContext;\n\n        public HelloActorBehavior(ActorContext&lt;Command&gt; ctx, SpringActorContext actorContext) {\n            this.ctx = ctx;\n            this.actorContext = actorContext;\n            // Call prestart hook for initialization logic\n            onPrestart();\n        }\n\n        private Behavior&lt;Command&gt; onSayHello(SayHello msg) {\n            // Send response\n            msg.reply(\"Hello from actor \" + actorContext.actorId());\n            return Behaviors.same();\n        }\n\n        private Behavior&lt;Command&gt; onTriggerFailure(TriggerFailure msg) {\n            // Throw exception to trigger restart (requires supervision strategy)\n            ctx.getLog().warn(\"Triggering failure for actor {}\", actorContext.actorId());\n            msg.replyTo.tell(\"Triggering failure - actor will restart\");\n            throw new RuntimeException(\"Intentional failure to demonstrate PreRestart\");\n        }\n\n        private void onPrestart() {\n            // Initialize resources when actor starts\n            ctx.getLog().info(\"PreStart hook for id={}\", actorContext.actorId());\n        }\n\n        private Behavior&lt;Command&gt; onPreRestart(PreRestart signal) {\n            // Cleanup before restart (e.g., close connections, release resources)\n            ctx.getLog().warn(\"Actor {} is being restarted\", actorContext.actorId());\n            return Behaviors.same();\n        }\n\n        private Behavior&lt;Command&gt; onPostStop(PostStop signal) {\n            // Final cleanup when actor stops\n            ctx.getLog().info(\"Actor {} is stopping\", actorContext.actorId());\n            return Behaviors.same();\n        }\n    }\n}\n</code></pre>"},{"location":"examples/simple/#helloservice","title":"HelloService","text":"<p><code>HelloService</code> acts as an intermediary between the REST API and the actor system:</p> <ul> <li>It spawns a HelloActor instance</li> <li>It provides methods to send messages to the actor and return the responses</li> <li>It converts actor responses to reactive Mono objects for use with Spring WebFlux</li> </ul> <pre><code>@Service\npublic class HelloService {\n    private final SpringActorSystem actorSystem;\n\n    public HelloService(SpringActorSystem actorSystem) {\n        this.actorSystem = actorSystem;\n    }\n\n    /**\n     * Best practice: Use getOrSpawn for simple cases where you don't need caching.\n     * It automatically handles the exists -&gt; get -&gt; spawn logic in a single call.\n     */\n    public Mono&lt;String&gt; hello() {\n        return Mono.fromCompletionStage(\n                actorSystem.getOrSpawn(HelloActor.class, \"hello-actor\")\n                        .thenCompose(actor -&gt; actor.ask(new HelloActor.SayHello())\n                                .withTimeout(Duration.ofSeconds(3))\n                                .execute()));\n    }\n}\n</code></pre>"},{"location":"examples/simple/#hellocontroller","title":"HelloController","text":"<p><code>HelloController</code> exposes the actor functionality via a REST API:</p> <ul> <li>It injects the HelloService</li> <li>It defines REST endpoints that call the service methods</li> <li>It returns the actor responses as HTTP responses</li> </ul> <pre><code>@RestController\npublic class HelloController {\n    private final HelloService helloService;\n\n    public HelloController(HelloService helloService) {\n        this.helloService = helloService;\n    }\n\n    @GetMapping(\"/hello\")\n    public Mono&lt;String&gt; hello() {\n        return helloService.hello();\n    }\n}\n</code></pre>"},{"location":"examples/simple/#actor-lifecycle-hooks","title":"Actor Lifecycle Hooks","text":"<p>The HelloActor demonstrates how to use lifecycle hooks to handle important events during an actor's lifetime. Pekko provides different mechanisms for handling startup and shutdown events.</p>"},{"location":"examples/simple/#prestart-hook","title":"PreStart Hook","text":"<p>Unlike restart and stop events which use signals, the prestart hook is implemented by calling a method in your behavior handler's constructor. This is the recommended approach for initialization logic when using the builder pattern.</p> <pre><code>@Override\npublic SpringActorBehavior&lt;Command&gt; create(SpringActorContext actorContext) {\n    return SpringActorBehavior.builder(Command.class, actorContext)\n            .withState(ctx -&gt; new HelloActorBehavior(ctx, actorContext))\n            .onMessage(SayHello.class, HelloActorBehavior::onSayHello)\n            .build();\n}\n\nprivate static class HelloActorBehavior {\n    private final ActorContext&lt;Command&gt; ctx;\n    private final SpringActorContext actorContext;\n\n    public HelloActorBehavior(ActorContext&lt;Command&gt; ctx, SpringActorContext actorContext) {\n        this.ctx = ctx;\n        this.actorContext = actorContext;\n        // Call prestart hook for initialization\n        onPrestart();\n    }\n\n    private void onPrestart() {\n        // Initialize resources when actor starts\n        ctx.getLog().info(\"Actor is starting...\");\n        // Open database connections, subscribe to events, etc.\n    }\n}\n</code></pre> <p>The prestart hook is useful for:</p> <ul> <li>Initializing resources (e.g., opening database connections, file handles)</li> <li>Subscribing to event streams or topics</li> <li>Setting up timers or scheduled tasks</li> <li>Loading initial state or configuration</li> <li>Logging actor startup</li> </ul>"},{"location":"examples/simple/#supervision-strategy","title":"Supervision Strategy","text":"<p>Important: To enable actor restarts on failure, you must specify a supervision strategy using the builder's <code>withSupervisionStrategy()</code> method. By default, Pekko stops actors when they throw exceptions. A supervision strategy tells Pekko what to do when an actor fails.</p> <pre><code>@Override\npublic SpringActorBehavior&lt;Command&gt; create(SpringActorContext actorContext) {\n    return SpringActorBehavior.builder(Command.class, actorContext)\n            .withState(ctx -&gt; new HelloActorBehavior(ctx, actorContext))\n            .onMessage(SayHello.class, HelloActorBehavior::onSayHello)\n            .onMessage(TriggerFailure.class, HelloActorBehavior::onTriggerFailure)\n            .onSignal(PreRestart.class, HelloActorBehavior::onPreRestart)\n            .onSignal(PostStop.class, HelloActorBehavior::onPostStop)\n            .withSupervisionStrategy(SupervisorStrategy.restart()\n                    .withLimit(10, Duration.ofMinutes(1)))\n            .build();\n}\n</code></pre> <p>This supervision strategy:</p> <ul> <li>Restarts the actor when any exception is thrown</li> <li>Limits restarts to 10 times within 1 minute to prevent infinite restart loops</li> <li>Enables the PreRestart signal to be triggered before restart</li> </ul> <p>Default Behavior</p> <p>Without a supervision strategy, actors stop permanently on failure. Always configure a strategy for production use.</p> <p>Common supervision strategies:</p> <ul> <li><code>restart()</code> - Restart the actor, discarding its state</li> <li><code>resume()</code> - Resume processing, keeping the actor's state</li> <li><code>stop()</code> - Stop the actor permanently (default behavior)</li> <li><code>restartWithBackoff()</code> - Restart with exponential backoff delays</li> </ul>"},{"location":"examples/simple/#prerestart-signal","title":"PreRestart Signal","text":"<p>The <code>PreRestart</code> signal is sent to an actor before it is restarted due to a failure. Note: This requires a supervision strategy with restart behavior. This is useful for:</p> <ul> <li>Cleaning up resources that won't be automatically released (e.g., closing database connections, file handles)</li> <li>Logging the state before restart for debugging</li> <li>Notifying other parts of the system about the restart</li> <li>Releasing locks or semaphores</li> </ul> <p>Note: The actor's state will be lost during restart unless you implement state persistence.</p>"},{"location":"examples/simple/#poststop-signal","title":"PostStop Signal","text":"<p>The <code>PostStop</code> signal is sent when an actor is stopped, either gracefully or due to a failure. This is the last chance to:</p> <ul> <li>Release resources (e.g., close connections, flush buffers)</li> <li>Perform final cleanup operations</li> <li>Notify other systems that the actor is shutting down</li> <li>Log final state information</li> </ul>"},{"location":"examples/simple/#using-lifecycle-hooks","title":"Using Lifecycle Hooks","text":"<p>To implement lifecycle hooks in your actor using the builder pattern:</p> <ol> <li>PreStart: Call a method in your behavior handler's constructor (within <code>.withState()</code>)</li> <li>PreRestart and PostStop: Use the <code>.onSignal()</code> method when building your behavior</li> <li>Supervision Strategy: Use <code>.withSupervisionStrategy()</code> to enable restarts</li> </ol> <pre><code>@Override\npublic SpringActorBehavior&lt;Command&gt; create(SpringActorContext actorContext) {\n    return SpringActorBehavior.builder(Command.class, actorContext)\n            // 1. PreStart: called in behavior handler constructor\n            .withState(ctx -&gt; new HelloActorBehavior(ctx, actorContext))\n            // 2. Message and signal handlers\n            .onMessage(SayHello.class, HelloActorBehavior::onSayHello)\n            .onSignal(PreRestart.class, HelloActorBehavior::onPreRestart)\n            .onSignal(PostStop.class, HelloActorBehavior::onPostStop)\n            // 3. Supervision strategy to enable restart\n            .withSupervisionStrategy(SupervisorStrategy.restart()\n                    .withLimit(10, Duration.ofMinutes(1)))\n            .build();\n}\n\nprivate static class HelloActorBehavior {\n    public HelloActorBehavior(ActorContext&lt;Command&gt; ctx, SpringActorContext actorContext) {\n        this.ctx = ctx;\n        this.actorContext = actorContext;\n        // PreStart hook called here\n        onPrestart();\n    }\n\n    private void onPrestart() {\n        ctx.getLog().info(\"Actor is starting...\");\n    }\n\n    private Behavior&lt;Command&gt; onPreRestart(PreRestart signal) {\n        ctx.getLog().warn(\"Actor is being restarted\");\n        return Behaviors.same();\n    }\n\n    private Behavior&lt;Command&gt; onPostStop(PostStop signal) {\n        ctx.getLog().info(\"Actor is stopping\");\n        return Behaviors.same();\n    }\n}\n</code></pre> <p>The signal handlers should return <code>Behaviors.same()</code> to indicate that the actor should continue with its normal lifecycle behavior.</p>"},{"location":"examples/simple/#testing-lifecycle-hooks","title":"Testing Lifecycle Hooks","text":"<p>The simple example provides API endpoints to test each lifecycle hook:</p>"},{"location":"examples/simple/#1-test-prestart-hook","title":"1. Test PreStart Hook","text":"<pre><code>curl http://localhost:8080/hello\n</code></pre> <p>Check the logs for: <code>PreStart hook for id=hello-actor</code></p>"},{"location":"examples/simple/#2-test-prerestart-signal","title":"2. Test PreRestart Signal","text":"<pre><code>curl http://localhost:8080/hello/restart\n</code></pre> <p>This triggers an intentional failure. Check the logs for:</p> <ul> <li><code>Triggering failure for actor hello-actor</code></li> <li><code>Actor hello-actor is being restarted</code> (PreRestart)</li> <li><code>PreStart hook for id=hello-actor</code> (actor restarts and PreStart is called again)</li> </ul>"},{"location":"examples/simple/#3-test-poststop-signal","title":"3. Test PostStop Signal","text":"<pre><code>curl http://localhost:8080/hello/stop\n</code></pre> <p>This stops the actor using <code>SpringActorHandle.stop()</code>. Check the logs for:</p> <ul> <li><code>Actor hello-actor is stopping</code> (PostStop)</li> </ul> <p>Testing Tips</p> <p>Watch the logs in your terminal when testing these endpoints to see the lifecycle hooks in action.</p>"},{"location":"examples/simple/#configuration","title":"Configuration","text":"<p>The simple example uses the default configuration for Spring Boot Starter Actor, which creates a local actor system. You can configure the actor system using application properties:</p> <pre><code>spring:\n  application:\n    name: spring-pekko\n  actor:\n    pekko:\n      actor:\n        provider: local\n</code></pre>"},{"location":"examples/simple/#running-the-example","title":"Running the Example","text":"<p>To run the simple example:</p> <ol> <li> <p>Navigate to the example directory: <pre><code>cd example/simple\n</code></pre></p> </li> <li> <p>Start the application using Gradle: <pre><code>./gradlew bootRun\n</code></pre></p> </li> <li> <p>Access the <code>/hello</code> endpoint to send a message to the actor: <pre><code>curl http://localhost:8080/hello\n</code></pre></p> </li> <li> <p>Observe the response from the actor in the terminal</p> </li> </ol> <p>Expected Output</p> <p>You should see <code>Hello from actor hello-actor</code> as the response.</p>"},{"location":"examples/simple/#key-points","title":"Key Points","text":"<ul> <li>Easy integration with Spring Boot - Actors work naturally with Spring's dependency injection</li> <li>Simple concurrency handling - Message-based processing eliminates need for locks</li> <li>Reactive programming support - Integrates seamlessly with Spring WebFlux and Mono/Flux</li> <li>Lifecycle management - Control actor initialization and cleanup with lifecycle hooks</li> </ul>"},{"location":"examples/simple/#next-steps","title":"Next Steps","text":"<ul> <li>Cluster Example - Learn about distributed actors and cluster sharding</li> <li>Chat Example - Build a real-world application with pub/sub topics</li> </ul>"},{"location":"examples/synchronization/","title":"Synchronization Example","text":"<p>This guide demonstrates how to implement efficient synchronization using Spring Boot Starter Actor, comparing it with traditional synchronization approaches.</p>"},{"location":"examples/synchronization/#overview","title":"Overview","text":"<p>The synchronization example shows how to:</p> <ul> <li>Implement counters with different synchronization mechanisms</li> <li>Compare database locking, Redis locking, and actor-based synchronization</li> <li>Handle concurrent access to shared resources</li> <li>Achieve high performance with actor-based synchronization</li> </ul> <p>This example demonstrates why using actors for synchronization is cheap and efficient compared to other approaches.</p>"},{"location":"examples/synchronization/#source-code","title":"Source Code","text":"<p>You can find the complete source code for this example on GitHub:</p> <p>Synchronization Example Source Code</p> <p>Performance Comparison</p> <p>This example includes benchmarking code to compare the performance of different synchronization approaches.</p>"},{"location":"examples/synchronization/#key-components","title":"Key Components","text":"<p>The example implements a counter service using three different synchronization approaches:</p> <ol> <li>Database Locking: Uses database transactions and locks</li> <li>Redis Locking: Uses Redis for distributed locking</li> <li>Actor-Based Synchronization: Uses actors for message-based synchronization</li> </ol> <p>Let's examine each approach to understand their differences and trade-offs.</p>"},{"location":"examples/synchronization/#counter-entity","title":"Counter Entity","text":"<p>The <code>Counter</code> class is a simple JPA entity representing a counter in the database:</p> <pre><code>@Entity\n@Table(name = \"counter\")\npublic class Counter {\n    @Id\n    @Column(name = \"counter_id\", nullable = false)\n    private String counterId;\n\n    @Column(name = \"value\", nullable = false)\n    private long value;\n\n    // Constructors, getters, setters...\n\n    public long increment() {\n        return ++value;\n    }\n}\n</code></pre>"},{"location":"examples/synchronization/#database-synchronization","title":"Database Synchronization","text":"<p><code>DbCounterService</code> uses database transactions and pessimistic locking to ensure synchronized access to counters:</p> <pre><code>@Service\npublic class DbCounterService implements CounterService {\n    private final CounterRepository counterRepository;\n    private final CustomTransactionTemplate customTransactionTemplate;\n\n    public DbCounterService(\n            CounterRepository counterRepository, \n            CustomTransactionTemplate customTransactionTemplate) {\n        this.counterRepository = counterRepository;\n        this.customTransactionTemplate = customTransactionTemplate;\n    }\n\n    @Override\n    public void increment(String counterId) {\n        incrementInternal(counterId);\n    }\n\n    @Override\n    public Mono&lt;Long&gt; getValue(String counterId) {\n        return Mono.fromCallable(() -&gt; getValueInternal(counterId))\n                .subscribeOn(Schedulers.boundedElastic());\n    }\n\n    public Long incrementInternal(String counterId) {\n        return customTransactionTemplate.runInTransaction(\n                () -&gt; {\n                    // Find counter with lock or create new one\n                    Counter counter =\n                            counterRepository\n                                    .findByIdWithLock(counterId)\n                                    .orElseGet(\n                                            () -&gt; {\n                                                return counterRepository.save(new Counter(counterId, 0));\n                                            });\n\n                    // Increment and save\n                    long newValue = counter.increment();\n                    counterRepository.save(counter);\n\n                    return newValue;\n                });\n    }\n\n    public Long getValueInternal(String counterId) {\n        return counterRepository.findById(counterId).map(Counter::getValue).orElse(0L);\n    }\n}\n</code></pre>"},{"location":"examples/synchronization/#redis-synchronization","title":"Redis Synchronization","text":"<p><code>RedisCounterService</code> uses Redis distributed locking to ensure synchronized access to counters:</p> <pre><code>@Service\npublic class RedisCounterService implements CounterService {\n    private static final String COUNTER_KEY_PREFIX = \"counter:\";\n    private static final String LOCK_KEY_PREFIX = \"counter:lock:\";\n    private static final Duration LOCK_TIMEOUT = Duration.ofSeconds(2);\n    private static final Duration RETRY_DELAY = Duration.ofMillis(100);\n    private static final int MAX_RETRIES = 50; // 5 seconds total retry time\n\n    private final ReactiveRedisTemplate&lt;String, Long&gt; redisTemplate;\n    private final ReactiveValueOperations&lt;String, Long&gt; valueOps;\n\n    public RedisCounterService(ReactiveRedisTemplate&lt;String, Long&gt; redisTemplate) {\n        this.redisTemplate = redisTemplate;\n        this.valueOps = redisTemplate.opsForValue();\n    }\n\n    @Override\n    public void increment(String counterId) {\n        String counterKey = COUNTER_KEY_PREFIX + counterId;\n        String lockKey = LOCK_KEY_PREFIX + counterId;\n\n        valueOps\n                .setIfAbsent(lockKey, 1L, LOCK_TIMEOUT)\n                .flatMap(locked -&gt; {\n                    if (!locked) {\n                        // Failed to acquire lock, retry\n                        return Mono.error(new RuntimeException(\"Failed to acquire lock\"));\n                    }\n\n                    return valueOps\n                            .increment(counterKey)\n                            .doFinally(signalType -&gt;\n                                       // Release lock when done\n                                       redisTemplate.delete(lockKey).subscribe());\n                })\n                .retryWhen(\n                        Retry.backoff(MAX_RETRIES, RETRY_DELAY))\n                .subscribe();\n    }\n\n    @Override\n    public Mono&lt;Long&gt; getValue(String counterId) {\n        String counterKey = COUNTER_KEY_PREFIX + counterId;\n        // Get the counter value or return 0 if it doesn't exist\n        return valueOps.get(counterKey).defaultIfEmpty(0L);\n    }\n}\n</code></pre>"},{"location":"examples/synchronization/#counteractor","title":"CounterActor","text":"<p><code>CounterActor</code> is a sharded actor that handles counter operations. Each counter is represented by a separate actor instance, identified by its counterId:</p> <pre><code>@Component\npublic class CounterActor implements SpringShardedActor&lt;CounterActor.Command&gt; {\n    public static final EntityTypeKey&lt;Command&gt; TYPE_KEY =\n            EntityTypeKey.create(Command.class, \"CounterActor\");\n\n    // Command interface and message types\n    public interface Command extends JsonSerializable {}\n\n    public static class Increment implements Command {\n        public Increment() {}\n    }\n\n    public static class GetValue extends AskCommand&lt;Long&gt; implements Command {\n        public GetValue() {}\n    }\n\n    // Implementation of SpringShardedActor methods...\n\n    private static class CounterActorBehavior {\n        private final ActorContext&lt;Command&gt; ctx;\n        private final String counterId;\n        private long value = 0;\n\n        // Constructor and behavior creation...\n\n        private Behavior&lt;Command&gt; onIncrement(Increment msg) {\n            value++;\n            return Behaviors.same();\n        }\n\n        private Behavior&lt;Command&gt; onGetValue(GetValue msg) {\n            msg.reply(value);\n            return Behaviors.same();\n        }\n    }\n}\n</code></pre>"},{"location":"examples/synchronization/#actorcounterservice","title":"ActorCounterService","text":"<p><code>ActorCounterService</code> uses actor-based synchronization to handle counter operations:</p> <pre><code>@Service\npublic class ActorCounterService implements CounterService {\n    private final SpringActorSystem springActorSystem;\n\n    public ActorCounterService(SpringActorSystem springActorSystem) {\n        this.springActorSystem = springActorSystem;\n    }\n\n    @Override\n    public void increment(String counterId) {\n        // Get a reference to the sharded actor for this counter\n        SpringShardedActorHandle&lt;CounterActor.Command&gt; actorRef =\n                springActorSystem.sharded(CounterActor.class).withId(counterId).get();\n\n        // Send an increment message to the actor\n        actorRef.tell(new CounterActor.Increment());\n    }\n\n    @Override\n    public Mono&lt;Long&gt; getValue(String counterId) {\n        // Get a reference to the sharded actor for this counter\n        SpringShardedActorHandle&lt;CounterActor.Command&gt; actorRef =\n                springActorSystem.sharded(CounterActor.class).withId(counterId).get();\n\n        // Send a get value message to the actor and get the response\n        CompletionStage&lt;Long&gt; response = actorRef\n                .ask(new CounterActor.GetValue())\n                .withTimeout(Duration.ofSeconds(3))\n                .execute();\n\n        return Mono.fromCompletionStage(response);\n    }\n}\n</code></pre>"},{"location":"examples/synchronization/#countercontroller","title":"CounterController","text":"<p><code>CounterController</code> exposes the counter functionality via HTTP endpoints for all three synchronization approaches:</p> <pre><code>@RestController\n@RequestMapping(\"/counter\")\npublic class CounterController {\n    private final DbCounterService dbCounterService;\n    private final RedisCounterService redisCounterService;\n    private final ActorCounterService actorCounterService;\n\n    // Constructor and endpoint methods for each service...\n\n    @GetMapping(\"/actor/{counterId}/increment\")\n    public void incrementActorCounter(@PathVariable String counterId) {\n        actorCounterService.increment(counterId);\n    }\n\n    @GetMapping(\"/actor/{counterId}\")\n    public Mono&lt;Long&gt; getActorCounter(@PathVariable String counterId) {\n        return actorCounterService.getValue(counterId);\n    }\n}\n</code></pre>"},{"location":"examples/synchronization/#actor-efficiency","title":"Actor Efficiency","text":"<p>Actors provide efficient synchronization through:</p> <ul> <li>Message-based concurrency without explicit locks</li> <li>Non-blocking asynchronous processing</li> <li>Independent actors that scale across nodes</li> <li>Reduced contention between different counters</li> <li>Built-in supervision and error handling</li> </ul> <p>Performance Benefits</p> <p>Actor-based synchronization typically outperforms database and Redis locking by 10-100x in high-concurrency scenarios.</p>"},{"location":"examples/synchronization/#performance-comparison","title":"Performance Comparison","text":"<p>When benchmarked under high concurrency:</p> <ol> <li>Database Locking - Slowest due to transaction overhead and lock contention</li> <li>Redis Locking - Better but has network overhead and retry loops</li> <li>Actor-Based Synchronization - Fastest with in-memory processing and no locks</li> </ol> <p>Benchmark Results</p> <p>Run the example and use a tool like Apache JMeter or wrk to benchmark the different endpoints under load.</p>"},{"location":"examples/synchronization/#next-steps","title":"Next Steps","text":"<ul> <li>Cluster Example - Distribute actors across multiple nodes</li> <li>Chat Example - Build real-time applications with actors</li> <li>Actor Registration Guide - Learn more about actor messaging patterns</li> </ul>"},{"location":"guides/actor-registration-messaging/","title":"Actor Registration and Messaging","text":"<p>This guide explains how to register actors, spawn them, and send messages using Spring Boot Starter Actor.</p>"},{"location":"guides/actor-registration-messaging/#registering-actors","title":"Registering Actors","text":"<p>In Spring Boot Starter Actor, actors are registered as Spring components. This allows them to be automatically discovered and managed by the Spring container.</p>"},{"location":"guides/actor-registration-messaging/#creating-a-simple-actor","title":"Creating a Simple Actor","text":"<p>To create an actor, implement the <code>SpringActor</code> interface and annotate the class with <code>@Component</code>:</p> <pre><code>@Component\npublic class HelloActor implements SpringActor&lt;HelloActor.Command&gt; {\n\n    // Define the command interface for messages this actor can handle\n    public interface Command {}\n\n    // Define a message type\n    public static class SayHi implements Command {}\n\n    // Define a message type\n    public static class SayHello extends AskCommand&lt;String&gt; implements Command {\n        public SayHello() {}\n    }\n\n    // Create the behavior for this actor\n    @Override\n    public SpringActorBehavior&lt;Command&gt; create(SpringActorContext actorContext) {\n        return SpringActorBehavior.builder(Command.class, actorContext)\n            .withState(ctx -&gt; new HelloActorBehavior(ctx, actorContext))\n            .onMessage(SayHi.class, HelloActorBehavior::onSayHi)\n            .onMessage(SayHello.class, HelloActorBehavior::onSayHello)\n            .build();\n    }\n\n    // Inner class to handle the actor's behavior\n    private static class HelloActorBehavior {\n        private final ActorContext&lt;Command&gt; ctx;\n        private final SpringActorContext actorContext;\n\n        HelloActorBehavior(ActorContext&lt;Command&gt; ctx, SpringActorContext actorContext) {\n            this.ctx = ctx;\n            this.actorContext = actorContext;\n        }\n\n        private Behavior&lt;Command&gt; onSayHi(SayHi msg) {\n            ctx.getLog().info(\"Received SayHi for id={}\", actorContext.actorId());\n            return Behaviors.same();\n        }\n\n        private Behavior&lt;Command&gt; onSayHello(SayHello msg) {\n            ctx.getLog().info(\"Received SayHello for id={}\", actorContext.actorId());\n            msg.reply(\"Hello from actor \" + actorContext.actorId());\n            return Behaviors.same();\n        }\n    }\n}\n</code></pre>"},{"location":"guides/actor-registration-messaging/#spawning-actors","title":"Spawning Actors","text":"<p>Once you've registered your actor, you can spawn instances of it using the <code>SpringActorSystem</code>.</p>"},{"location":"guides/actor-registration-messaging/#recommended-use-getorspawn-simplified-api","title":"Recommended: Use getOrSpawn (Simplified API)","text":"<p>The recommended way to work with actors is using <code>getOrSpawn()</code>, which automatically handles the actor lifecycle:</p> <pre><code>@Service\npublic class HelloService {\n    private final SpringActorSystem actorSystem;\n\n    public HelloService(SpringActorSystem actorSystem) {\n        this.actorSystem = actorSystem;\n    }\n\n    /**\n     * Best practice: Use getOrSpawn for simple cases where you don't need caching.\n     * It automatically handles the exists -&gt; get -&gt; spawn logic in a single call.\n     */\n    public Mono&lt;String&gt; hello() {\n        return Mono.fromCompletionStage(\n                actorSystem.getOrSpawn(HelloActor.class, \"hello-actor\")\n                        .thenCompose(actor -&gt; actor.ask(new HelloActor.SayHello())\n                                .withTimeout(Duration.ofSeconds(3))\n                                .execute()));\n    }\n}\n</code></pre> <p>When to use getOrSpawn</p> <p>Use <code>getOrSpawn()</code> for most cases as it simplifies actor lifecycle management and reduces boilerplate code.</p>"},{"location":"guides/actor-registration-messaging/#advanced-explicit-spawning-with-builder-api","title":"Advanced: Explicit Spawning with Builder API","text":"<p>For advanced scenarios requiring custom configuration (supervision strategies, dispatchers, mailboxes), use the fluent builder API:</p> <pre><code>@Service\npublic class HelloService {\n\n    private final SpringActorHandle&lt;HelloActor.Command&gt; helloActor;\n\n    public HelloService(SpringActorSystem springActorSystem) {\n        // Spawn an actor using the fluent builder API\n        this.helloActor = springActorSystem\n                .actor(HelloActor.class)\n                .withId(\"default\")\n                .withTimeout(Duration.ofSeconds(3))\n                .spawnAndWait();\n    }\n\n    // Service methods...\n}\n</code></pre>"},{"location":"guides/actor-registration-messaging/#advanced-async-spawning-with-configuration","title":"Advanced: Async Spawning with Configuration","text":"<p>For non-blocking actor creation with custom configuration:</p> <pre><code>@Service\npublic class HelloService {\n    private final CompletionStage&lt;SpringActorHandle&lt;HelloActor.Command&gt;&gt; helloActor;\n\n    public HelloService(SpringActorSystem springActorSystem) {\n        // Spawn asynchronously\n        this.helloActor = springActorSystem\n                .actor(HelloActor.class)\n                .withId(\"default\")\n                .withTimeout(\"3s\")  // Can use string format\n                .spawn();\n    }\n\n    public Mono&lt;String&gt; hello() {\n        return Mono.fromCompletionStage(\n            helloActor.thenCompose(actor -&gt;\n                actor.ask(new HelloActor.SayHello())\n                    .withTimeout(Duration.ofSeconds(3))\n                    .execute()\n            )\n        );\n    }\n}\n</code></pre>"},{"location":"guides/actor-registration-messaging/#advanced-configuration","title":"Advanced Configuration","text":"<p>The fluent API supports additional configuration options for advanced use cases:</p> <pre><code>SpringActorHandle&lt;HelloActor.Command&gt; actor = springActorSystem\n        .actor(HelloActor.class)\n        .withId(\"myActor\")\n        .withTimeout(Duration.ofSeconds(5))\n        .withMailbox(MailboxConfig.bounded(100)) // For mailbox customization \n        .withBlockingDispatcher()  // For blocking I/O operations\n        .asClusterSingleton()     // For cluster singleton actors\n        .withContext(customContext)  // Custom actor context\n        .spawn();\n</code></pre> <p>Learn more about dispatchers:</p> <ul> <li>See the Dispatchers Guide for detailed information about thread management and dispatcher configuration</li> </ul>"},{"location":"guides/actor-registration-messaging/#sending-messages-to-actors","title":"Sending Messages to Actors","text":"<p>Once you have a reference to an actor, you can send messages to it:</p>"},{"location":"guides/actor-registration-messaging/#tell-pattern-fire-and-forget","title":"Tell Pattern (Fire-and-Forget)","text":"<p>The tell pattern is used when you don't need a response from the actor:</p> <pre><code>public void hi() {\n    actorSystem.getOrSpawn(HelloActor.class, \"hello-actor\")\n            .thenAccept(actor -&gt; actor.tell(new HelloActor.SayHi()));\n}\n</code></pre>"},{"location":"guides/actor-registration-messaging/#ask-pattern-request-response","title":"Ask Pattern (Request-Response)","text":"<p>The ask pattern is used when you expect a response from the actor:</p> <pre><code>public Mono&lt;String&gt; hello() {\n    return Mono.fromCompletionStage(\n            actorSystem.getOrSpawn(HelloActor.class, \"hello-actor\")\n                    .thenCompose(actor -&gt; actor.ask(new HelloActor.SayHello())\n                            .withTimeout(Duration.ofSeconds(3))\n                            .execute()));\n}\n</code></pre>"},{"location":"guides/actor-registration-messaging/#stopping-actors","title":"Stopping Actors","text":"<p>You can gracefully stop actors when they are no longer needed:</p>"},{"location":"guides/actor-registration-messaging/#simplified-stop-api","title":"Simplified Stop API","text":"<pre><code>actorRef.stop();\n</code></pre> <p>Actor Termination</p> <p>Stopping an actor is permanent. You'll need to spawn a new instance if you need the actor again.</p>"},{"location":"guides/actor-registration-messaging/#actor-lifecycle-operations","title":"Actor Lifecycle Operations","text":""},{"location":"guides/actor-registration-messaging/#checking-if-an-actor-exists","title":"Checking if an Actor Exists","text":"<p>Check if an actor is already running before creating a new instance:</p> <pre><code>CompletionStage&lt;Boolean&gt; exists = actorSystem\n    .exists(MyActor.class, \"my-actor-1\");\n\n// With custom timeout\nexists = actorSystem.exists(MyActor.class, \"my-actor-1\", Duration.ofMillis(500));\n</code></pre>"},{"location":"guides/actor-registration-messaging/#getting-an-existing-actor-reference","title":"Getting an Existing Actor Reference","text":"<p>Retrieve a reference to an existing actor without creating a new instance:</p> <pre><code>CompletionStage&lt;SpringActorHandle&lt;Command&gt;&gt; actorRef = actorSystem\n    .get(MyActor.class, \"my-actor-1\");\n\n// With custom timeout\nactorRef = actorSystem.get(MyActor.class, \"my-actor-1\", Duration.ofMillis(500));\n\n// Returns null if actor doesn't exist\n</code></pre>"},{"location":"guides/actor-registration-messaging/#get-or-create-pattern-recommended","title":"Get or Create Pattern (Recommended)","text":"<p>Simple Approach - Use <code>getOrSpawn</code>:</p> <p>The <code>getOrSpawn</code> method automatically handles the exists/get/spawn logic:</p> <pre><code>// Recommended: Use getOrSpawn for simplified actor lifecycle management\nCompletionStage&lt;SpringActorHandle&lt;Command&gt;&gt; actorRef = actorSystem\n    .getOrSpawn(MyActor.class, \"my-actor-1\");\n\n// With custom timeout\nactorRef = actorSystem.getOrSpawn(MyActor.class, \"my-actor-1\", Duration.ofSeconds(5));\n</code></pre> <p>Manual Approach (for advanced cases):</p> <p>If you need more control, you can manually check exists and spawn:</p> <pre><code>actorSystem.exists(MyActor.class, \"my-actor-1\")\n    .thenCompose(exists -&gt; {\n        if (exists) {\n            return actorSystem.get(MyActor.class, \"my-actor-1\");\n        } else {\n            return actorSystem.actor(MyActor.class)\n                .withId(\"my-actor-1\")\n                .spawn();\n        }\n    });\n</code></pre>"},{"location":"guides/actor-registration-messaging/#lazy-initialization-pattern","title":"Lazy Initialization Pattern","text":"<p>Simple Approach (Recommended for most cases):</p> <p>Use <code>getOrSpawn</code> directly - it's simple, efficient, and handles the lifecycle automatically:</p> <pre><code>@Service\npublic class HelloService {\n    private final SpringActorSystem actorSystem;\n\n    public HelloService(SpringActorSystem actorSystem) {\n        this.actorSystem = actorSystem;\n    }\n\n    /**\n     * getOrSpawn handles the exists/get/spawn logic automatically.\n     * This is the recommended approach for most use cases.\n     */\n    public Mono&lt;String&gt; hello() {\n        return Mono.fromCompletionStage(\n                actorSystem.getOrSpawn(HelloActor.class, \"hello-actor\")\n                        .thenCompose(actor -&gt;\n                            actor.ask(new HelloActor.SayHello())\n                                .withTimeout(Duration.ofSeconds(3))\n                                .execute()));\n    }\n}\n</code></pre> <p>With Caching (For high-frequency access):</p> <p>If the same actor is accessed very frequently, cache the reference to avoid repeated lookups:</p> <pre><code>@Service\npublic class HelloService {\n    private final SpringActorSystem actorSystem;\n    private final AtomicReference&lt;CompletionStage&lt;SpringActorHandle&lt;HelloActor.Command&gt;&gt;&gt; actorRef =\n            new AtomicReference&lt;&gt;();\n\n    public HelloService(SpringActorSystem actorSystem) {\n        this.actorSystem = actorSystem;\n    }\n\n    /**\n     * Lazily initializes the actor on first use and caches the reference\n     * for subsequent calls. Use this for high-frequency access scenarios.\n     */\n    private CompletionStage&lt;SpringActorHandle&lt;HelloActor.Command&gt;&gt; getActor() {\n        return actorRef.updateAndGet(existing -&gt;\n                existing != null ? existing : actorSystem.getOrSpawn(HelloActor.class, \"hello-actor\")\n        );\n    }\n\n    public Mono&lt;String&gt; hello() {\n        return Mono.fromCompletionStage(\n                getActor().thenCompose(actor -&gt;\n                    actor.ask(new HelloActor.SayHello())\n                        .withTimeout(Duration.ofSeconds(3))\n                        .execute()));\n    }\n}\n</code></pre>"},{"location":"guides/actor-registration-messaging/#spawning-child-actors","title":"Spawning Child Actors","text":"<p>Child actors can be spawned from within parent actors using the fluent child builder API. This provides a consistent and type-safe way to manage actor hierarchies.</p>"},{"location":"guides/actor-registration-messaging/#basic-child-spawning","title":"Basic Child Spawning","text":"<p>Use the <code>child()</code> method on <code>SpringActorHandle</code> to spawn child actors:</p> <pre><code>@Component\npublic class ParentActor implements SpringActor&lt;ParentActor.Command&gt; {\n\n    public interface Command extends FrameworkCommand {}\n\n    @Override\n    public SpringActorBehavior&lt;Command&gt; create(SpringActorContext actorContext) {\n        return SpringActorBehavior.builder(Command.class, actorContext)\n            .withState(ctx -&gt; {\n                // Get reference to self\n                SpringActorHandle&lt;Command&gt; self = new SpringActorHandle&lt;&gt;(\n                    ctx.getSystem().scheduler(), ctx.getSelf());\n\n                // Spawn a child actor using fluent API\n                self.child(ChildActor.class)\n                    .withId(\"worker-1\")\n                    .withSupervisionStrategy(SupervisorStrategy.restart())\n                    .withTimeout(Duration.ofSeconds(5))\n                    .spawn();  // Returns CompletionStage&lt;SpringActorHandle&gt;\n\n                return new ParentBehavior(ctx, actorContext);\n            })\n            .build();\n    }\n}\n</code></pre>"},{"location":"guides/actor-registration-messaging/#child-actor-operations","title":"Child Actor Operations","text":"<p>The child builder API supports several operations:</p> <p>Spawn a new child: <pre><code>CompletionStage&lt;SpringActorHandle&lt;Command&gt;&gt; child = parentRef\n    .child(ChildActor.class)\n    .withId(\"child-1\")\n    .withSupervisionStrategy(SupervisorStrategy.restart())\n    .spawn();  // Async\n\n// Or synchronous spawning\nSpringActorHandle&lt;Command&gt; child = parentRef\n    .child(ChildActor.class)\n    .withId(\"child-2\")\n    .withSupervisionStrategy(SupervisorStrategy.restart())\n    .spawnAndWait();  // Blocks until spawned\n</code></pre></p> <p>Get existing child reference: <pre><code>CompletionStage&lt;SpringActorHandle&lt;Command&gt;&gt; existing = parentRef\n    .child(ChildActor.class)\n    .withId(\"child-1\")\n    .get();  // Returns null if not found\n</code></pre></p> <p>Check if child exists: <pre><code>CompletionStage&lt;Boolean&gt; exists = parentRef\n    .child(ChildActor.class)\n    .withId(\"child-1\")\n    .exists();\n</code></pre></p> <p>Get existing or spawn new (recommended): <pre><code>CompletionStage&lt;SpringActorHandle&lt;Command&gt;&gt; childRef = parentRef\n    .child(ChildActor.class)\n    .withId(\"child-1\")\n    .getOrSpawn();  // Gets existing or creates new\n</code></pre></p>"},{"location":"guides/actor-registration-messaging/#child-actor-with-custom-context","title":"Child Actor with Custom Context","text":"<p>You can provide custom context for child actors:</p> <pre><code>SpringActorContext customContext = new SpringActorContext() {\n    @Override\n    public String actorId() {\n        return \"custom-child-id\";\n    }\n};\n\nSpringActorHandle&lt;Command&gt; child = parentRef\n    .child(ChildActor.class)\n    .withContext(customContext)\n    .withSupervisionStrategy(SupervisorStrategy.restart())\n    .spawnAndWait();\n</code></pre>"},{"location":"guides/actor-registration-messaging/#supervision-strategies-for-children","title":"Supervision Strategies for Children","text":"<p>Apply different supervision strategies based on the child's role:</p> <pre><code>// Restart strategy for stateless workers\nself.child(WorkerActor.class)\n    .withId(\"worker\")\n    .withSupervisionStrategy(SupervisorStrategy.restart())\n    .spawn();\n\n// Limited restart for production systems\nself.child(WorkerActor.class)\n    .withId(\"critical-worker\")\n    .withSupervisionStrategy(SupervisorStrategy.restart().withLimit(3, Duration.ofMinutes(1)))\n    .spawn();\n\n// Stop strategy for actors that should fail fast\nself.child(ValidatorActor.class)\n    .withId(\"validator\")\n    .withSupervisionStrategy(SupervisorStrategy.stop())\n    .spawn();\n\n// Resume strategy for non-critical failures\nself.child(LoggerActor.class)\n    .withId(\"logger\")\n    .withSupervisionStrategy(SupervisorStrategy.resume())\n    .spawn();\n</code></pre>"},{"location":"guides/actor-registration-messaging/#best-practices","title":"Best Practices","text":"<ol> <li>Use getOrSpawn: For most cases, use <code>getOrSpawn()</code> instead of manually checking exists/get/spawn - it's simpler and reduces boilerplate</li> <li>Lazy Initialization: Use lazy initialization to avoid blocking application startup. For simple cases, use <code>getOrSpawn</code> directly; for high-frequency access, add caching with <code>AtomicReference</code></li> <li>Actor Hierarchy: Organize actors in a hierarchy to manage their lifecycle and supervision</li> <li>Choose Appropriate Supervision: Select supervision strategies based on the child actor's role and failure characteristics</li> <li>Use Framework Commands: Make your Command interface extend <code>FrameworkCommand</code> when building parent actors that need to spawn children. Framework command handling is automatically enabled</li> <li>Message Immutability: Ensure that messages sent to actors are immutable to prevent concurrency issues</li> <li>Timeout Handling: Always specify reasonable timeouts for ask operations and handle timeout exceptions using <code>ask().onTimeout()</code></li> <li>Non-Blocking Operations: Avoid blocking operations inside actors, as they can lead to thread starvation</li> <li>Actor Naming: Use meaningful and unique names for actors to make debugging easier</li> <li>Use Fluent API for Advanced Cases: For advanced scenarios requiring custom configuration (supervision, dispatchers, mailboxes), use the fluent builder API with <code>.actor()</code>. For simple cases, prefer <code>getOrSpawn()</code></li> </ol>"},{"location":"guides/actor-registration-messaging/#next-steps","title":"Next Steps","text":"<p>Now that you know how to register actors, spawn them, and send messages, you can:</p> <ol> <li>Learn how to use pub/sub topics for distributed messaging</li> <li>Explore routers for load balancing and parallel processing</li> <li>Create sharded actors for clustered environments</li> </ol>"},{"location":"guides/dispatchers/","title":"Dispatchers","text":"<p>This guide explains how to use dispatchers to control thread execution for your actors.</p>"},{"location":"guides/dispatchers/#what-are-dispatchers","title":"What are Dispatchers?","text":"<p>A dispatcher is the \"engine\" that makes Pekko Actors work. It is responsible for selecting which actors receive messages and allocating threads from the thread pool.</p> <p>By default, all actors use Pekko's default dispatcher, but you can configure actors to use different dispatchers based on their workload characteristics.</p>"},{"location":"guides/dispatchers/#why-use-different-dispatchers","title":"Why Use Different Dispatchers?","text":"<p>The main reason to use different dispatchers is to isolate blocking operations from the default dispatcher. If you perform blocking operations (like blocking I/O) on the default dispatcher, it can starve the thread pool and prevent other actors from processing messages.</p>"},{"location":"guides/dispatchers/#dispatcher-selection-api","title":"Dispatcher Selection API","text":"<p>Spring Boot Starter Actor provides a fluent API for selecting dispatchers when spawning actors:</p>"},{"location":"guides/dispatchers/#default-dispatcher","title":"Default Dispatcher","text":"<p>Use the default Pekko dispatcher (this is the default behavior):</p> <pre><code>SpringActorHandle&lt;MyActor.Command&gt; actor = actorSystem\n    .actor(MyActor.class)\n    .withId(\"my-actor\")\n    .withDefaultDispatcher()  // Optional - this is the default\n    .spawnAndWait();\n</code></pre>"},{"location":"guides/dispatchers/#blocking-dispatcher","title":"Blocking Dispatcher","text":"<p>Use Pekko's default blocking I/O dispatcher for actors that perform blocking operations:</p> <pre><code>SpringActorHandle&lt;DatabaseActor.Command&gt; dbActor = actorSystem\n    .actor(DatabaseActor.class)\n    .withId(\"db-actor\")\n    .withBlockingDispatcher()  // Use blocking I/O dispatcher\n    .spawnAndWait();\n</code></pre>"},{"location":"guides/dispatchers/#when-to-use","title":"When to use:","text":"<ul> <li>Database operations</li> <li>File I/O</li> <li>Network calls (blocking APIs)</li> <li>Any operation that blocks the thread</li> </ul>"},{"location":"guides/dispatchers/#custom-dispatcher-from-configuration","title":"Custom Dispatcher from Configuration","text":"<p>Use a custom dispatcher defined in your application configuration:</p> <pre><code>SpringActorHandle&lt;WorkerActor.Command&gt; worker = actorSystem\n    .actor(WorkerActor.class)\n    .withId(\"worker\")\n    .withDispatcherFromConfig(\"my-custom-dispatcher\")\n    .spawnAndWait();\n</code></pre>"},{"location":"guides/dispatchers/#same-as-parent-dispatcher","title":"Same-as-Parent Dispatcher","text":"<p>Inherit the dispatcher from the parent actor (useful for child actors):</p> <pre><code>SpringActorHandle&lt;ChildActor.Command&gt; child = parentRef\n    .child(ChildActor.class)\n    .withId(\"child\")\n    .withDispatcherSameAsParent()\n    .spawnAndWait();\n</code></pre>"},{"location":"guides/dispatchers/#types-of-dispatchers","title":"Types of Dispatchers","text":""},{"location":"guides/dispatchers/#dispatcher-default","title":"Dispatcher (Default)","text":"<p>The default dispatcher is used when no specific dispatcher is configured. It uses a fork-join-executor by default and provides excellent performance for non-blocking operations.</p> <p>Fork-Join Executor</p> <p>The fork-join executor is a work-stealing thread pool that provides efficient CPU utilization for non-blocking workloads.</p>"},{"location":"guides/dispatchers/#pinneddispatcher","title":"PinnedDispatcher","text":"<p>A PinnedDispatcher dedicates a unique thread for each actor using it. This can be useful for actors that need thread-local state or for bulkheading critical actors.</p> <p>Resource Usage</p> <p>PinnedDispatcher creates one thread per actor, which can lead to high resource consumption. Use sparingly and only when necessary.</p>"},{"location":"guides/dispatchers/#configuring-custom-dispatchers","title":"Configuring Custom Dispatchers","text":"<p>Define custom dispatchers in your <code>application.yml</code>:</p>"},{"location":"guides/dispatchers/#fork-join-executor","title":"Fork-Join Executor","text":"<p>The fork-join-executor is a work-stealing thread pool:</p> <pre><code>spring:\n  actor:\n    my-dispatcher:\n      type: Dispatcher\n      executor: fork-join-executor\n      fork-join-executor:\n        # Min number of threads\n        parallelism-min: 2\n        # Thread count = ceil(available processors * factor)\n        parallelism-factor: 2.0\n        # Max number of threads\n        parallelism-max: 10\n      # Throughput defines the maximum number of messages\n      # to be processed per actor before the thread jumps\n      # to the next actor. Set to 1 for as fair as possible.\n      throughput: 100\n</code></pre>"},{"location":"guides/dispatchers/#thread-pool-executor","title":"Thread Pool Executor","text":"<p>The thread-pool-executor is based on a <code>java.util.concurrent.ThreadPoolExecutor</code>:</p> <pre><code>spring:\n  actor:\n    my-blocking-dispatcher:\n      type: Dispatcher\n      executor: thread-pool-executor\n      thread-pool-executor:\n        # Fixed pool size\n        fixed-pool-size: 16\n      throughput: 1\n</code></pre>"},{"location":"guides/dispatchers/#dynamic-thread-pool-executor","title":"Dynamic Thread Pool Executor","text":"<p>For variable pool sizes:</p> <pre><code>spring:\n  actor:\n    my-dynamic-dispatcher:\n      type: Dispatcher\n      executor: thread-pool-executor\n      thread-pool-executor:\n        core-pool-size-min: 4\n        core-pool-size-factor: 2.0\n        core-pool-size-max: 16\n        max-pool-size-min: 8\n        max-pool-size-factor: 2.0\n        max-pool-size-max: 32\n      throughput: 10\n</code></pre>"},{"location":"guides/dispatchers/#virtual-thread-executor-java-21","title":"Virtual Thread Executor (Java 21+)","text":"<p>If you're running on Java 21 or later, you can use Pekko's built-in virtual thread executor for actors performing blocking I/O operations. Virtual threads are lightweight threads that provide excellent scalability for blocking operations.</p> <p>Benefits of Virtual Threads:</p> <ul> <li>Very low memory overhead (~1KB per thread vs ~1MB for platform threads)</li> <li>Can handle millions of concurrent operations</li> <li>Ideal for blocking I/O (database calls, HTTP requests, file operations)</li> <li>No need for reactive programming patterns</li> </ul> <p>Java 21+ Required</p> <p>Virtual thread support requires Java 21 or later. If you're on Java 11-17, use thread-pool-executor instead.</p> <p>Configuration:</p> <pre><code>spring:\n  actor:\n    virtual-thread-dispatcher:\n      executor: virtual-thread-executor\n</code></pre> <p>Usage:</p> <pre><code>SpringActorHandle&lt;DatabaseActor.Command&gt; dbActor = actorSystem\n    .actor(DatabaseActor.class)\n    .withId(\"db-actor\")\n    .withDispatcherFromConfig(\"virtual-thread-dispatcher\")\n    .spawnAndWait();\n</code></pre> <p>JVM Tuning (Optional):</p> <p>You can further configure virtual threads using JVM system properties:</p> <ul> <li><code>jdk.virtualThreadScheduler.parallelism</code> - Number of platform threads for virtual thread scheduling</li> <li><code>jdk.virtualThreadScheduler.maxPoolSize</code> - Maximum pool size for virtual thread scheduler</li> <li><code>jdk.unparker.maxPoolSize</code> - Maximum pool size for unparking virtual threads</li> </ul> <p>When to Tune</p> <p>Most applications don't need to tune these settings. Only adjust if you've identified specific bottlenecks through profiling.</p> <p>Requirements: - Java 21 or later - Suitable for blocking I/O operations only (not CPU-intensive tasks)</p> <p>When to use Virtual Threads vs Thread Pool:</p> Use Case Recommended Dispatcher Blocking I/O (Java 21+) Virtual Thread Executor Blocking I/O (Java 11-17) Thread Pool Executor CPU-intensive tasks Fork-Join Executor (default) Non-blocking operations Default Dispatcher <p>Virtual Threads Example</p> <p>See the virtual-threads example for a complete working demonstration of virtual threads with actors.</p>"},{"location":"guides/dispatchers/#blocking-operations","title":"Blocking Operations","text":"<p>The most important reason to use a separate dispatcher is to isolate blocking operations from the default dispatcher.</p> <p>Problem:</p> <p>If you have blocking operations (such as blocking I/O, database calls, or expensive computations) and run them on the default dispatcher, it will block threads that are needed for other actors to process their messages. This can cause your application to become unresponsive.</p> <p>Solution:</p> <p>Always use a separate dispatcher with a thread pool executor for actors that perform blocking operations. Use <code>.withBlockingDispatcher()</code> or a custom dispatcher with a thread-pool-executor.</p> <p>Thread Starvation</p> <p>Running blocking operations on the default dispatcher can lead to thread starvation, where all threads are blocked waiting for I/O, preventing other actors from processing messages.</p> <p>Example configuration for blocking operations:</p> <pre><code>spring:\n  actor:\n    my-blocking-dispatcher:\n      type: Dispatcher\n      executor: thread-pool-executor\n      thread-pool-executor:\n        fixed-pool-size: 16\n      throughput: 1\n</code></pre>"},{"location":"guides/dispatchers/#throughput-configuration","title":"Throughput Configuration","text":"<p>The <code>throughput</code> setting defines the maximum number of messages to be processed per actor before the thread jumps to the next actor. Set to 1 for as fair as possible.</p> <p>Higher throughput values can improve performance by reducing the number of context switches, but may increase latency for individual messages.</p>"},{"location":"guides/dispatchers/#more-information","title":"More Information","text":"<p>For more detailed information about dispatchers, refer to the Pekko Dispatcher Documentation.</p>"},{"location":"guides/dispatchers/#next-steps","title":"Next Steps","text":"<ul> <li>Actor Registration - Learn how to create and spawn actors</li> <li>Routers - Use routers for load balancing and parallel processing</li> <li>Logging with MDC - Enhance observability with MDC and tags</li> </ul>"},{"location":"guides/logging/","title":"Logging with MDC and Tags","text":"<p>This guide explains how to use MDC (Mapped Diagnostic Context) and actor tags to enhance observability and debugging in your actor-based applications.</p>"},{"location":"guides/logging/#what-is-mdc","title":"What is MDC?","text":"<p>MDC (Mapped Diagnostic Context) is a mechanism for adding contextual information to log entries. It allows you to attach key-value pairs to logs, making it easier to trace requests, correlate events, and filter logs in production environments.</p> <p>Common use cases for MDC include:</p> <ul> <li>Request and correlation IDs for distributed tracing</li> <li>User identifiers for auditing</li> <li>Session IDs for tracking user sessions</li> <li>Transaction IDs for monitoring business operations</li> </ul>"},{"location":"guides/logging/#what-are-actor-tags","title":"What are Actor Tags?","text":"<p>Actor tags are labels that you can attach to actors for categorization and filtering. Tags appear in the <code>pekkoTags</code> MDC property and are particularly useful for:</p> <ul> <li>Grouping actors by role (worker, supervisor, coordinator)</li> <li>Identifying workload characteristics (cpu-intensive, io-bound)</li> <li>Categorizing by service (order-service, payment-service)</li> <li>Marking priority levels (critical, high-priority, low-priority)</li> </ul> <p>Tag Usage</p> <p>Use tags liberally to categorize actors. They're lightweight and make filtering logs much easier in production.</p>"},{"location":"guides/logging/#automatic-mdc-values","title":"Automatic MDC Values","text":"<p>Pekko automatically adds these MDC properties to all actor log entries:</p> Property Description Example <code>pekkoSource</code> The actor's path <code>pekko://MySystem/user/my-actor</code> <code>pekkoAddress</code> The ActorSystem address <code>pekko://MySystem@localhost:25520</code> <code>pekkoTags</code> Comma-separated list of tags <code>worker,high-priority</code> <code>sourceActorSystem</code> The ActorSystem name <code>MySystem</code>"},{"location":"guides/logging/#using-static-mdc","title":"Using Static MDC","text":"<p>Static MDC values are set when spawning an actor and remain constant throughout the actor's lifetime.</p>"},{"location":"guides/logging/#spawning-with-static-mdc","title":"Spawning with Static MDC","text":"<pre><code>@Service\npublic class OrderService {\n\n    private final SpringActorSystem actorSystem;\n\n    public OrderService(SpringActorSystem actorSystem) {\n        this.actorSystem = actorSystem;\n    }\n\n    public void createOrderProcessor(String userId, String sessionId) {\n        Map&lt;String, String&gt; mdc = Map.of(\n            \"userId\", userId,\n            \"sessionId\", sessionId,\n            \"service\", \"order-service\"\n        );\n\n        SpringActorHandle&lt;OrderActor.Command&gt; processor = actorSystem\n            .actor(OrderActor.class)\n            .withId(\"order-processor-\" + userId)\n            .withMdc(MdcConfig.of(mdc))\n            .spawnAndWait();\n    }\n}\n</code></pre> <p>All log entries from this actor will include the static MDC values:</p> <pre><code>[INFO] [userId=user-123] [sessionId=session-abc] [service=order-service] Processing order\n</code></pre> <p>Static vs Dynamic</p> <p>Use static MDC for values that remain constant throughout the actor's lifetime. For per-message values, use dynamic MDC instead.</p>"},{"location":"guides/logging/#using-dynamic-mdc","title":"Using Dynamic MDC","text":"<p>Dynamic MDC values are computed per-message, allowing you to add message-specific context to logs.</p>"},{"location":"guides/logging/#adding-dynamic-mdc-to-actor-behavior","title":"Adding Dynamic MDC to Actor Behavior","text":"<pre><code>@Component\npublic class OrderActor implements SpringActor&lt;OrderActor.Command&gt; {\n\n    public interface Command {}\n\n    public static class ProcessOrder implements Command {\n        public final String orderId;\n        public final String userId;\n\n        public ProcessOrder(String orderId, String userId) {\n            this.orderId = orderId;\n            this.userId = userId;\n        }\n    }\n\n    @Override\n    public SpringActorBehavior&lt;Command&gt; create(SpringActorContext actorContext) {\n        return SpringActorBehavior.builder(Command.class, actorContext)\n            .withMdc(msg -&gt; {\n                if (msg instanceof ProcessOrder) {\n                    ProcessOrder order = (ProcessOrder) msg;\n                    return Map.of(\n                        \"orderId\", order.orderId,\n                        \"userId\", order.userId\n                    );\n                }\n                return Map.of();\n            })\n            .onMessage(ProcessOrder.class, (ctx, msg) -&gt; {\n                // orderId and userId are now in MDC\n                ctx.getLog().info(\"Processing order\");\n                return Behaviors.same();\n            })\n            .build();\n    }\n}\n</code></pre> <p>Log output includes dynamic values:</p> <pre><code>[INFO] [orderId=order-456] [userId=cust-789] Processing order\n</code></pre> <p>Dynamic MDC Pattern</p> <p>Dynamic MDC is perfect for per-message context like request IDs, order IDs, or any data that varies with each message.</p>"},{"location":"guides/logging/#combining-static-and-dynamic-mdc","title":"Combining Static and Dynamic MDC","text":"<p>You can use both static and dynamic MDC together. Static values provide actor-level context, while dynamic values add message-level context.</p> <pre><code>// Spawn with static MDC\nMap&lt;String, String&gt; staticMdc = Map.of(\n    \"service\", \"payment-service\",\n    \"region\", \"us-east-1\"\n);\n\nSpringActorHandle&lt;PaymentActor.Command&gt; actor = actorSystem\n    .actor(PaymentActor.class)\n    .withId(\"payment-processor\")\n    .withMdc(MdcConfig.of(staticMdc))\n    .spawnAndWait();\n</code></pre> <pre><code>// Actor with dynamic MDC\n@Component\npublic class PaymentActor implements SpringActor&lt;PaymentActor.Command&gt; {\n\n    @Override\n    public SpringActorBehavior&lt;Command&gt; create(SpringActorContext actorContext) {\n        return SpringActorBehavior.builder(Command.class, actorContext)\n            .withMdc(msg -&gt; {\n                if (msg instanceof ProcessPayment) {\n                    ProcessPayment payment = (ProcessPayment) msg;\n                    return Map.of(\n                        \"paymentId\", payment.paymentId,\n                        \"amount\", String.valueOf(payment.amount)\n                    );\n                }\n                return Map.of();\n            })\n            .onMessage(ProcessPayment.class, (ctx, msg) -&gt; {\n                // Both static and dynamic MDC values are available\n                ctx.getLog().info(\"Processing payment\");\n                return Behaviors.same();\n            })\n            .build();\n    }\n}\n</code></pre> <p>Log output combines both: <pre><code>[INFO] [service=payment-service] [region=us-east-1] [paymentId=pay-123] [amount=99.99] Processing payment\n</code></pre></p>"},{"location":"guides/logging/#using-actor-tags","title":"Using Actor Tags","text":"<p>Actor tags provide a way to categorize actors for easier log filtering and analysis.</p>"},{"location":"guides/logging/#spawning-with-tags","title":"Spawning with Tags","text":"<pre><code>// Single tag\nSpringActorHandle&lt;Worker.Command&gt; worker = actorSystem\n    .actor(Worker.class)\n    .withId(\"worker-1\")\n    .withTags(TagsConfig.of(\"worker\"))\n    .spawnAndWait();\n\n// Multiple tags\nSpringActorHandle&lt;Worker.Command&gt; priorityWorker = actorSystem\n    .actor(Worker.class)\n    .withId(\"worker-2\")\n    .withTags(TagsConfig.of(\"worker\", \"high-priority\", \"cpu-intensive\"))\n    .spawnAndWait();\n\n// Tags from a set\nSet&lt;String&gt; tags = Set.of(\"worker\", \"backend\");\nSpringActorHandle&lt;Worker.Command&gt; backendWorker = actorSystem\n    .actor(Worker.class)\n    .withId(\"worker-3\")\n    .withTags(TagsConfig.of(tags))\n    .spawnAndWait();\n</code></pre> <p>Tags appear in the <code>pekkoTags</code> MDC property: <pre><code>[INFO] [pekkoSource=pekko://MySystem/user/worker-2] [pekkoTags=worker,high-priority,cpu-intensive] Processing task\n</code></pre></p>"},{"location":"guides/logging/#common-tag-categories","title":"Common Tag Categories","text":"<p>Organize your actors using meaningful tag categories:</p> <pre><code>// By role\nTagsConfig.of(\"worker\", \"coordinator\", \"supervisor\")\n\n// By priority\nTagsConfig.of(\"critical\", \"high-priority\", \"low-priority\")\n\n// By service\nTagsConfig.of(\"order-service\", \"payment-service\", \"notification-service\")\n\n// By workload\nTagsConfig.of(\"cpu-intensive\", \"io-bound\", \"memory-intensive\")\n\n// By environment\nTagsConfig.of(\"production\", \"staging\", \"development\")\n</code></pre>"},{"location":"guides/logging/#child-actors-with-mdc-and-tags","title":"Child Actors with MDC and Tags","text":"<p>Child actors can have their own MDC values and tags independent of their parents.</p> <pre><code>@Component\npublic class ParentActor implements SpringActor&lt;ParentActor.Command&gt; {\n\n    public interface Command extends FrameworkCommand {}\n\n    @Override\n    public SpringActorBehavior&lt;Command&gt; create(SpringActorContext actorContext) {\n        return SpringActorBehavior.builder(Command.class, actorContext)\n            .withState(ctx -&gt; {\n                SpringActorHandle&lt;Command&gt; self = new SpringActorHandle&lt;&gt;(\n                    ctx.getSystem().scheduler(), ctx.getSelf());\n\n                // Spawn child with its own MDC and tags\n                self.child(ChildActor.class)\n                    .withId(\"worker-child\")\n                    .withTags(TagsConfig.of(\"child\", \"worker\"))\n                    .withMdc(MdcConfig.of(Map.of(\"childId\", \"worker-1\")))\n                    .spawn();\n\n                return new ParentBehavior(ctx, actorContext);\n            })\n            .build();\n    }\n}\n</code></pre> <p>Child actors do not inherit parent MDC values, ensuring isolation: - Parent logs: <code>[parentId=parent-1] [sessionId=session-abc]</code> - Child logs: <code>[childId=worker-1] [pekkoTags=child,worker]</code></p>"},{"location":"guides/logging/#configuring-logback-for-mdc","title":"Configuring Logback for MDC","text":"<p>Configure your <code>logback.xml</code> to display MDC values in log output.</p>"},{"location":"guides/logging/#basic-logback-configuration","title":"Basic Logback Configuration","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration&gt;\n    &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{ISO8601} %-5level [%X{pekkoSource}] [%X{pekkoTags}] [%X{userId}] [%X{requestId}] %logger{36} - %msg%n&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;root level=\"INFO\"&gt;\n        &lt;appender-ref ref=\"CONSOLE\"/&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre>"},{"location":"guides/logging/#async-appender-for-production","title":"Async Appender for Production","text":"<p>Use async logging to avoid blocking actors:</p> <pre><code>&lt;configuration&gt;\n    &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt;\n        &lt;file&gt;logs/application.log&lt;/file&gt;\n        &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt;\n            &lt;fileNamePattern&gt;logs/application.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;\n            &lt;maxHistory&gt;30&lt;/maxHistory&gt;\n        &lt;/rollingPolicy&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{ISO8601} %-5level [%X{pekkoSource}] [%X{pekkoTags}] %X{userId} %X{requestId} - %msg%n&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;appender name=\"ASYNC\" class=\"ch.qos.logback.classic.AsyncAppender\"&gt;\n        &lt;queueSize&gt;1024&lt;/queueSize&gt;\n        &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt;\n        &lt;appender-ref ref=\"FILE\"/&gt;\n    &lt;/appender&gt;\n\n    &lt;root level=\"INFO\"&gt;\n        &lt;appender-ref ref=\"ASYNC\"/&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre>"},{"location":"guides/logging/#json-logging-for-structured-logs","title":"JSON Logging for Structured Logs","text":"<p>For production environments and log aggregation systems:</p> <pre><code>&lt;configuration&gt;\n    &lt;appender name=\"JSON\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;encoder class=\"net.logstash.logback.encoder.LogstashEncoder\"&gt;\n            &lt;includeMdcKeyName&gt;pekkoSource&lt;/includeMdcKeyName&gt;\n            &lt;includeMdcKeyName&gt;pekkoAddress&lt;/includeMdcKeyName&gt;\n            &lt;includeMdcKeyName&gt;pekkoTags&lt;/includeMdcKeyName&gt;\n            &lt;includeMdcKeyName&gt;sourceActorSystem&lt;/includeMdcKeyName&gt;\n            &lt;includeMdcKeyName&gt;userId&lt;/includeMdcKeyName&gt;\n            &lt;includeMdcKeyName&gt;requestId&lt;/includeMdcKeyName&gt;\n            &lt;includeMdcKeyName&gt;orderId&lt;/includeMdcKeyName&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;root level=\"INFO\"&gt;\n        &lt;appender-ref ref=\"JSON\"/&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre> <p>Add the dependency in <code>build.gradle</code>: <pre><code>implementation 'net.logstash.logback:logstash-logback-encoder:7.4'\n</code></pre></p>"},{"location":"guides/logging/#best-practices","title":"Best Practices","text":""},{"location":"guides/logging/#1-use-static-mdc-for-actor-level-context","title":"1. Use Static MDC for Actor-Level Context","text":"<p>Use static MDC for values that remain constant throughout an actor's lifetime: <pre><code>// Good: Static values like userId, service name\n.withMdc(MdcConfig.of(Map.of(\"userId\", userId, \"service\", \"orders\")))\n</code></pre></p>"},{"location":"guides/logging/#2-use-dynamic-mdc-for-message-level-context","title":"2. Use Dynamic MDC for Message-Level Context","text":"<p>Use dynamic MDC for values that change per message: <pre><code>// Good: Message-specific values like requestId, orderId\n.withMdc(msg -&gt; Map.of(\"requestId\", msg.getRequestId()))\n</code></pre></p>"},{"location":"guides/logging/#3-use-tags-for-categorization","title":"3. Use Tags for Categorization","text":"<p>Use tags to group and filter actors by characteristics: <pre><code>// Good: Categorize by role, priority, and workload\n.withTags(TagsConfig.of(\"worker\", \"high-priority\", \"cpu-intensive\"))\n</code></pre></p>"},{"location":"guides/logging/#4-keep-mdc-keys-consistent","title":"4. Keep MDC Keys Consistent","text":"<p>Use consistent naming conventions for MDC keys across your application: <pre><code>// Good: Consistent naming\n\"userId\", \"requestId\", \"orderId\", \"sessionId\"\n\n// Bad: Inconsistent naming\n\"user_id\", \"request-id\", \"OrderID\", \"SESSION_ID\"\n</code></pre></p>"},{"location":"guides/logging/#5-avoid-sensitive-data-in-logs","title":"5. Avoid Sensitive Data in Logs","text":"<p>Never include sensitive information in MDC values: <pre><code>// Bad: Sensitive data\nMap.of(\"password\", password, \"creditCard\", ccNumber)\n\n// Good: Use identifiers only\nMap.of(\"userId\", userId, \"transactionId\", transactionId)\n</code></pre></p>"},{"location":"guides/logging/#6-use-async-logging-in-production","title":"6. Use Async Logging in Production","text":"<p>Always use async appenders to prevent logging from blocking actor processing:</p> <pre><code>&lt;appender name=\"ASYNC\" class=\"ch.qos.logback.classic.AsyncAppender\"&gt;\n    &lt;queueSize&gt;1024&lt;/queueSize&gt;\n    &lt;appender-ref ref=\"FILE\"/&gt;\n&lt;/appender&gt;\n</code></pre> <p>Blocking Logging</p> <p>Synchronous logging can significantly impact actor throughput. Always use async appenders in production.</p>"},{"location":"guides/logging/#7-filter-logs-by-tags","title":"7. Filter Logs by Tags","text":"<p>Use tags to filter logs in production: <pre><code># Filter by specific tag\ngrep \"pekkoTags=worker\" application.log\n\n# Filter by multiple tags\ngrep \"pekkoTags=.*high-priority.*\" application.log\n</code></pre></p>"},{"location":"guides/logging/#8-monitor-mdc-overhead","title":"8. Monitor MDC Overhead","text":"<p>Be mindful of the number of MDC keys to avoid performance impact: <pre><code>// Good: 3-5 MDC keys\nMap.of(\"userId\", userId, \"requestId\", requestId, \"service\", service)\n\n// Avoid: Too many MDC keys\nMap.of(\"key1\", val1, \"key2\", val2, ..., \"key20\", val20)\n</code></pre></p>"},{"location":"guides/logging/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/logging/#request-tracing","title":"Request Tracing","text":"<p>Track requests across multiple actors:</p> <pre><code>@Component\npublic class RequestHandler implements SpringActor&lt;RequestHandler.Command&gt; {\n\n    @Override\n    public SpringActorBehavior&lt;Command&gt; create(SpringActorContext actorContext) {\n        return SpringActorBehavior.builder(Command.class, actorContext)\n            .withMdc(msg -&gt; {\n                if (msg instanceof HandleRequest) {\n                    HandleRequest request = (HandleRequest) msg;\n                    return Map.of(\n                        \"requestId\", request.requestId,\n                        \"traceId\", request.traceId,\n                        \"spanId\", request.spanId\n                    );\n                }\n                return Map.of();\n            })\n            .onMessage(HandleRequest.class, (ctx, msg) -&gt; {\n                ctx.getLog().info(\"Handling request\");\n                // requestId, traceId, spanId are in MDC\n                return Behaviors.same();\n            })\n            .build();\n    }\n}\n</code></pre>"},{"location":"guides/logging/#user-session-tracking","title":"User Session Tracking","text":"<p>Track user sessions throughout the application:</p> <pre><code>SpringActorHandle&lt;SessionActor.Command&gt; sessionActor = actorSystem\n    .actor(SessionActor.class)\n    .withId(\"session-\" + sessionId)\n    .withMdc(MdcConfig.of(Map.of(\n        \"sessionId\", sessionId,\n        \"userId\", userId,\n        \"ipAddress\", ipAddress\n    )))\n    .spawnAndWait();\n</code></pre>"},{"location":"guides/logging/#service-categorization","title":"Service Categorization","text":"<p>Organize actors by service:</p> <pre><code>// Order service actors\nactorSystem.actor(OrderProcessor.class)\n    .withId(\"order-processor\")\n    .withTags(TagsConfig.of(\"order-service\", \"critical\"))\n    .withMdc(MdcConfig.of(Map.of(\"service\", \"orders\")))\n    .spawn();\n\n// Payment service actors\nactorSystem.actor(PaymentProcessor.class)\n    .withId(\"payment-processor\")\n    .withTags(TagsConfig.of(\"payment-service\", \"critical\"))\n    .withMdc(MdcConfig.of(Map.of(\"service\", \"payments\")))\n    .spawn();\n</code></pre>"},{"location":"guides/logging/#integration-with-observability-tools","title":"Integration with Observability Tools","text":""},{"location":"guides/logging/#elastic-stack-elk","title":"Elastic Stack (ELK)","text":"<p>Use JSON logging with Logstash encoder for easy ingestion: <pre><code>&lt;encoder class=\"net.logstash.logback.encoder.LogstashEncoder\"&gt;\n    &lt;customFields&gt;{\"application\":\"my-app\",\"environment\":\"production\"}&lt;/customFields&gt;\n&lt;/encoder&gt;\n</code></pre></p>"},{"location":"guides/logging/#distributed-tracing","title":"Distributed Tracing","text":"<p>Add trace and span IDs to MDC for correlation with tracing systems: <pre><code>.withMdc(msg -&gt; Map.of(\n    \"traceId\", msg.getTraceId(),\n    \"spanId\", msg.getSpanId()\n))\n</code></pre></p>"},{"location":"guides/logging/#log-aggregation","title":"Log Aggregation","text":"<p>Use consistent tag naming for easier queries: <pre><code>// Query in Kibana/Grafana\npekkoTags:worker AND service:orders AND environment:production\n</code></pre></p>"},{"location":"guides/logging/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/logging/#mdc-values-not-appearing-in-logs","title":"MDC Values Not Appearing in Logs","text":"<p>Check your Logback pattern includes <code>%X{keyName}</code>: <pre><code>&lt;pattern&gt;%d{ISO8601} [%X{userId}] [%X{requestId}] - %msg%n&lt;/pattern&gt;\n</code></pre></p>"},{"location":"guides/logging/#tags-not-showing-up","title":"Tags Not Showing Up","text":"<p>Verify you're using <code>.withTags()</code> when spawning: <pre><code>.withTags(TagsConfig.of(\"worker\"))  // Required\n</code></pre></p> <p>And include <code>%X{pekkoTags}</code> in your pattern: <pre><code>&lt;pattern&gt;[%X{pekkoTags}] %msg%n&lt;/pattern&gt;\n</code></pre></p>"},{"location":"guides/logging/#performance-issues-with-logging","title":"Performance Issues with Logging","text":"<p>Use async appenders and appropriate queue sizes: <pre><code>&lt;appender name=\"ASYNC\" class=\"ch.qos.logback.classic.AsyncAppender\"&gt;\n    &lt;queueSize&gt;1024&lt;/queueSize&gt;\n    &lt;neverBlock&gt;true&lt;/neverBlock&gt;\n&lt;/appender&gt;\n</code></pre></p>"},{"location":"guides/logging/#more-information","title":"More Information","text":"<p>For more information about logging and observability:</p> <ul> <li>Actor Registration and Messaging - Learn how to create and spawn actors</li> <li>Dispatchers - Configure thread execution for your actors</li> <li>Pekko Typed Logging Documentation</li> <li>Logback Configuration</li> </ul>"},{"location":"guides/logging/#next-steps","title":"Next Steps","text":"<ul> <li>Sharded Actors - Learn about distributed entity management in clusters</li> <li>Persistence with Spring Boot - Integrate actors with Spring Data</li> </ul>"},{"location":"guides/persistence-spring-boot/","title":"Spring Boot Integration","text":"<p>How to leverage spring-boot-starter-actor with Spring Boot's ecosystem.</p>"},{"location":"guides/persistence-spring-boot/#core-philosophy","title":"Core Philosophy","text":"<p>Actors are just Spring components. They use dependency injection, configuration, and all standard Spring Boot features\u2014no special setup required.</p> <p>Spring-Native</p> <p>The library is designed to feel like native Spring Boot. If you know Spring Boot, you already know how to use actors.</p>"},{"location":"guides/persistence-spring-boot/#quick-start","title":"Quick Start","text":""},{"location":"guides/persistence-spring-boot/#1-enable-actor-support","title":"1. Enable Actor Support","text":"<pre><code>@SpringBootApplication\n@EnableActorSupport  // That's it!\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n</code></pre>"},{"location":"guides/persistence-spring-boot/#2-create-an-actor","title":"2. Create an Actor","text":"<pre><code>@Component  // Regular Spring component\npublic class OrderActor implements SpringActor&lt;Command&gt; {\n    private final OrderRepository repository;  // Injected automatically\n    private final OrderService service;        // Any Spring bean works\n\n    // Constructor injection like any Spring component\n    public OrderActor(OrderRepository repository, OrderService service) {\n        this.repository = repository;\n        this.service = service;\n    }\n\n    @Override\n    public SpringActorBehavior&lt;Command&gt; create(SpringActorContext ctx) {\n        return SpringActorBehavior.builder(Command.class, ctx)\n            .withState(actorCtx -&gt; new OrderBehavior(actorCtx, repository, service))\n            .onMessage(CreateOrder.class, OrderBehavior::handleCreate)\n            .build();\n    }\n\n    private static class OrderBehavior {\n        private final ActorContext&lt;Command&gt; ctx;\n        private final OrderRepository repository;\n        private final OrderService service;\n\n        public OrderBehavior(ActorContext&lt;Command&gt; ctx, OrderRepository repository, OrderService service) {\n            this.ctx = ctx;\n            this.repository = repository;\n            this.service = service;\n        }\n\n        private Behavior&lt;Command&gt; handleCreate(CreateOrder cmd) {\n            // Implementation here\n            return Behaviors.same();\n        }\n    }\n}\n</code></pre>"},{"location":"guides/persistence-spring-boot/#3-use-actors-from-controllers","title":"3. Use Actors from Controllers","text":"<pre><code>@RestController\npublic class OrderController {\n    private final SpringActorSystem actorSystem;  // Auto-configured\n\n    public OrderController(SpringActorSystem actorSystem) {\n        this.actorSystem = actorSystem;\n    }\n\n    @PostMapping(\"/orders/{orderId}\")\n    public CompletionStage&lt;OrderResponse&gt; createOrder(\n            @PathVariable String orderId,\n            @RequestBody CreateOrderRequest request) {\n\n        return actorSystem.getOrSpawn(OrderActor.class, orderId)\n            .thenCompose(ref -&gt; ref.ask(new CreateOrder(request))\n                .withTimeout(Duration.ofSeconds(5))\n                .execute());\n    }\n}\n</code></pre>"},{"location":"guides/persistence-spring-boot/#spring-data-integration","title":"Spring Data Integration","text":""},{"location":"guides/persistence-spring-boot/#jpa-repositories","title":"JPA Repositories","text":"<p>Inject JPA repositories directly into actors:</p> <pre><code>@Component\npublic class OrderActor implements SpringActor&lt;Command&gt; {\n    private final OrderRepository orderRepository;\n\n    public OrderActor(OrderRepository orderRepository) {\n        this.orderRepository = orderRepository;\n    }\n\n    @Override\n    public SpringActorBehavior&lt;Command&gt; create(SpringActorContext ctx) {\n        return SpringActorBehavior.builder(Command.class, ctx)\n            .withState(actorCtx -&gt; {\n                // Load state on startup from database\n                Order order = orderRepository.findByOrderId(ctx.actorId()).orElse(null);\n                return new OrderBehavior(actorCtx, orderRepository, order);\n            })\n            .onMessage(UpdateOrder.class, OrderBehavior::handleUpdate)\n            .build();\n    }\n\n    private static class OrderBehavior {\n        private final ActorContext&lt;Command&gt; ctx;\n        private final OrderRepository orderRepository;\n        private Order currentOrder;\n\n        public OrderBehavior(ActorContext&lt;Command&gt; ctx, OrderRepository orderRepository, Order order) {\n            this.ctx = ctx;\n            this.orderRepository = orderRepository;\n            this.currentOrder = order;\n        }\n\n        private Behavior&lt;Command&gt; handleUpdate(UpdateOrder cmd) {\n            if (currentOrder == null) {\n                cmd.reply(new OrderResponse(false, null, \"Order not found\"));\n                return Behaviors.same();\n            }\n\n            currentOrder.setAmount(cmd.getNewAmount());\n            currentOrder = orderRepository.save(currentOrder);  // Explicit save\n            ctx.getLog().info(\"Order updated: {}\", currentOrder.getOrderId());\n            cmd.reply(new OrderResponse(true, currentOrder, \"Order updated\"));\n            return Behaviors.same();\n        }\n    }\n}\n</code></pre>"},{"location":"guides/persistence-spring-boot/#reactive-repositories","title":"Reactive Repositories","text":"<p>Use reactive repositories for non-blocking operations:</p> <pre><code>@Component\npublic class ReactiveOrderActor implements SpringActor&lt;Command&gt; {\n    private final ReactiveOrderRepository repository;\n\n    public ReactiveOrderActor(ReactiveOrderRepository repository) {\n        this.repository = repository;\n    }\n\n    @Override\n    public SpringActorBehavior&lt;Command&gt; create(SpringActorContext ctx) {\n        return SpringActorBehavior.builder(Command.class, ctx)\n            .withState(actorCtx -&gt; new ReactiveBehavior(actorCtx, repository))\n            .onMessage(SaveOrder.class, ReactiveBehavior::handleSave)\n            .onMessage(SaveComplete.class, ReactiveBehavior::handleComplete)\n            .build();\n    }\n\n    // Internal messages for async results\n    private record SaveComplete(Order order) implements Command {}\n\n    private static class ReactiveBehavior {\n        private final ActorContext&lt;Command&gt; ctx;\n        private final ReactiveOrderRepository repository;\n        private Order currentOrder;\n\n        public ReactiveBehavior(ActorContext&lt;Command&gt; ctx, ReactiveOrderRepository repository) {\n            this.ctx = ctx;\n            this.repository = repository;\n        }\n\n        private Behavior&lt;Command&gt; handleSave(SaveOrder cmd) {\n            repository.save(currentOrder)\n                .subscribe(\n                    saved -&gt; ctx.getSelf().tell(new SaveComplete(saved)),\n                    error -&gt; ctx.getLog().error(\"Save failed\", error)\n                );\n            return Behaviors.same();\n        }\n\n        private Behavior&lt;Command&gt; handleComplete(SaveComplete msg) {\n            this.currentOrder = msg.order();\n            ctx.getLog().info(\"Order saved successfully: {}\", currentOrder.getId());\n            return Behaviors.same();\n        }\n    }\n}\n</code></pre>"},{"location":"guides/persistence-spring-boot/#handling-blocking-operations","title":"Handling Blocking Operations","text":"<p>Database operations (JPA, JDBC) are blocking and should not run on the default actor dispatcher. Use a dedicated blocking dispatcher to prevent thread starvation.</p> <pre><code>@RestController\npublic class OrderController {\n    private final SpringActorSystem actorSystem;\n\n    @PostMapping(\"/orders/{orderId}\")\n    public CompletionStage&lt;OrderResponse&gt; createOrder(@PathVariable String orderId, ...) {\n        return actorSystem.actor(OrderActor.class)\n            .withId(orderId)\n            .withBlockingDispatcher()  // Configure dispatcher here\n            .spawn()\n            .thenCompose(ref -&gt; ref.ask(new CreateOrder(...))\n                .withTimeout(Duration.ofSeconds(5))\n                .execute());\n    }\n}\n</code></pre> <p>Thread Starvation</p> <p>Never run blocking database operations on the default dispatcher. Always use a blocking dispatcher or configure a custom thread pool.</p> <p>See the Dispatchers guide for detailed configuration and best practices.</p>"},{"location":"guides/persistence-spring-boot/#spring-boot-features","title":"Spring Boot Features","text":""},{"location":"guides/persistence-spring-boot/#configuration-properties","title":"Configuration Properties","text":"<p>Use <code>@ConfigurationProperties</code> for actor configuration:</p> <pre><code>@ConfigurationProperties(prefix = \"app.orders\")\npublic class OrderConfig {\n    private int maxRetries = 3;\n    private Duration timeout = Duration.ofSeconds(5);\n    private SnapshotConfig snapshot = new SnapshotConfig();\n\n    public static class SnapshotConfig {\n        private int operationInterval = 100;\n        private long timeIntervalMillis = 60000;\n        // getters/setters\n    }\n    // getters/setters\n}\n</code></pre> <pre><code>app:\n  orders:\n    max-retries: 5\n    timeout: 10s\n    snapshot:\n      operation-interval: 50\n      time-interval-millis: 30000\n</code></pre> <p>Inject into actors:</p> <pre><code>@Component\npublic class OrderActor implements SpringActor&lt;Command&gt; {\n    private final OrderRepository orderRepository;\n    private final OrderConfig config;  // Injected automatically\n\n    public OrderActor(OrderRepository orderRepository, OrderConfig config) {\n        this.orderRepository = orderRepository;\n        this.config = config;\n    }\n\n    @Override\n    public SpringActorBehavior&lt;Command&gt; create(SpringActorContext ctx) {\n        return SpringActorBehavior.builder(Command.class, ctx)\n            .withState(actorCtx -&gt; {\n                SnapshotStrategy strategy = new HybridSnapshotStrategy(\n                    config.getSnapshot().getOperationInterval(),\n                    config.getSnapshot().getTimeIntervalMillis()\n                );\n                return new OrderBehavior(actorCtx, orderRepository, strategy);\n            })\n            .onMessage(CreateOrder.class, OrderBehavior::handleCreate)\n            .build();\n    }\n}\n</code></pre>"},{"location":"guides/persistence-spring-boot/#transaction-management","title":"Transaction Management","text":"<p>Actors can use Spring's declarative transactions:</p> <pre><code>@Service\npublic class OrderService {\n    private final OrderRepository orderRepository;\n    private final OrderItemRepository itemRepository;\n\n    @Transactional  // Standard Spring transaction\n    public Order createOrderWithItems(String orderId, List&lt;OrderItem&gt; items) {\n        Order order = new Order(orderId);\n        order = orderRepository.save(order);\n\n        for (OrderItem item : items) {\n            item.setOrder(order);\n            itemRepository.save(item);\n        }\n\n        return order;\n    }\n}\n\n@Component\npublic class OrderActor implements SpringActor&lt;Command&gt; {\n    private final OrderService orderService;  // Inject service with @Transactional\n\n    @Override\n    public SpringActorBehavior&lt;Command&gt; create(SpringActorContext ctx) {\n        return SpringActorBehavior.builder(Command.class, ctx)\n            .withState(actorCtx -&gt; new OrderBehavior(actorCtx, orderService))\n            .onMessage(CreateOrder.class, OrderBehavior::handleCreate)\n            .build();\n    }\n\n    private static class OrderBehavior {\n        private final ActorContext&lt;Command&gt; ctx;\n        private final OrderService orderService;\n\n        public OrderBehavior(ActorContext&lt;Command&gt; ctx, OrderService orderService) {\n            this.ctx = ctx;\n            this.orderService = orderService;\n        }\n\n        private Behavior&lt;Command&gt; handleCreate(CreateOrder cmd) {\n            List&lt;OrderItem&gt; items = cmd.getItems();\n            Order order = orderService.createOrderWithItems(ctx.actorId(), items);\n            // Transaction is managed by Spring\n            ctx.getLog().info(\"Order created with items: {}\", order.getOrderId());\n            cmd.reply(new OrderResponse(true, order, \"Order created\"));\n            return Behaviors.same();\n        }\n    }\n}\n</code></pre>"},{"location":"guides/persistence-spring-boot/#complete-example","title":"Complete Example","text":"<p>See <code>example/persistence</code> for a complete working example demonstrating:</p> <ul> <li>JPA integration with actors</li> <li>Transaction management</li> <li>Blocking dispatcher configuration</li> <li>State loading and persistence</li> </ul> <p>Example Code</p> <p>The persistence example shows a complete implementation of actors with Spring Data JPA integration.</p>"},{"location":"guides/persistence-spring-boot/#summary","title":"Summary","text":"<p>Spring Boot integration is seamless:</p> <ol> <li>Actors are Spring components - Use <code>@Component</code>, inject dependencies normally</li> <li>SpringActorSystem is auto-configured - Just inject and use</li> <li>Use Spring Data directly - No adapters or wrappers needed</li> <li>Standard Spring Boot features work - Configuration, profiles, actuator, testing</li> <li>CompletionStage integrates with Spring MVC/WebFlux - Async responses just work</li> </ol> <p>No Special Setup</p> <p>No special setup. No custom infrastructure. Just Spring Boot + actors.</p>"},{"location":"guides/persistence-spring-boot/#next-steps","title":"Next Steps","text":"<ul> <li>Dispatchers - Configure thread execution for blocking operations</li> <li>Sharded Actors - Distribute actors across a cluster</li> <li>Logging with MDC - Add observability to your actors</li> </ul>"},{"location":"guides/pub-sub-topics/","title":"Pub/Sub Topics","text":"<p>Pub/Sub topics enable one-to-many messaging where publishers broadcast messages to multiple subscribers without knowing who they are.</p>"},{"location":"guides/pub-sub-topics/#overview","title":"Overview","text":"<p>Key Features:</p> <ul> <li>Distributed across cluster nodes</li> <li>Decoupled publishers and subscribers</li> <li>Automatic subscriber management</li> <li>Works in both local and cluster modes</li> </ul> <p>Use Cases:</p> <ul> <li>Broadcasting events (chat rooms, notifications)</li> <li>Real-time updates to multiple actors</li> <li>Event-driven architectures</li> </ul> <p>Not Suitable For:</p> <ul> <li>Point-to-point messaging (use direct actor references)</li> <li>Guaranteed delivery (topics are at-most-once)</li> <li>Request-response patterns (use ask)</li> </ul>"},{"location":"guides/pub-sub-topics/#creating-topics","title":"Creating Topics","text":"<p>Inject <code>SpringTopicManager</code> and use it to create topics:</p> <pre><code>@Service\npublic class ChatService {\n    private final SpringTopicManager topicManager;\n\n    public ChatService(SpringTopicManager topicManager) {\n        this.topicManager = topicManager;\n    }\n\n    public SpringTopicRef&lt;ChatMessage&gt; getChatRoomTopic(String roomId) {\n        return topicManager\n            .topic(ChatMessage.class)\n            .withName(\"chat-room-\" + roomId)\n            .getOrCreate();  // Idempotent - safe to call multiple times\n    }\n}\n</code></pre> <p>Methods:</p> <ul> <li><code>getOrCreate()</code> - Recommended. Creates if doesn't exist, returns existing if it does</li> <li><code>create()</code> - Throws exception if topic already exists</li> </ul> <p>Idempotent Creation</p> <p>Always prefer <code>getOrCreate()</code> over <code>create()</code> to make your code idempotent and avoid exceptions when the topic already exists.</p> <p>Message Requirements:</p> <p>Messages must implement <code>JsonSerializable</code> or <code>CborSerializable</code>:</p> <pre><code>public static class ChatMessage implements JsonSerializable {\n    public final String userId;\n    public final String content;\n\n    public ChatMessage(String userId, String content) {\n        this.userId = userId;\n        this.content = content;\n    }\n}\n</code></pre>"},{"location":"guides/pub-sub-topics/#publishing-messages","title":"Publishing Messages","text":"<pre><code>SpringTopicRef&lt;ChatMessage&gt; topic = topicManager\n    .topic(ChatMessage.class)\n    .withName(\"chat-room-lobby\")\n    .getOrCreate();\n\ntopic.publish(new ChatMessage(\"user123\", \"Hello everyone!\"));\n</code></pre> <p>Notes:</p> <ul> <li>Fire-and-forget, at-most-once delivery</li> <li>Safe to publish even if no subscribers exist</li> </ul> <p>At-Most-Once Delivery</p> <p>Pub/sub topics provide at-most-once delivery semantics. Messages are not guaranteed to be delivered if subscribers are temporarily unavailable.</p>"},{"location":"guides/pub-sub-topics/#subscribing-to-topics","title":"Subscribing to Topics","text":"<pre><code>@Service\npublic class ChatService {\n    private final SpringTopicManager topicManager;\n    private final SpringActorSystem actorSystem;\n\n    public CompletionStage&lt;Void&gt; joinChatRoom(String userId, String roomId) {\n        SpringTopicRef&lt;ChatMessage&gt; roomTopic = topicManager\n            .topic(ChatMessage.class)\n            .withName(\"chat-room-\" + roomId)\n            .getOrCreate();\n\n        return actorSystem\n            .getOrSpawn(UserActor.class, \"user-\" + userId)\n            .thenAccept(userActor -&gt; roomTopic.subscribe(userActor));\n    }\n\n    public CompletionStage&lt;Void&gt; leaveChatRoom(String userId, String roomId) {\n        SpringTopicRef&lt;ChatMessage&gt; roomTopic = topicManager\n            .topic(ChatMessage.class)\n            .withName(\"chat-room-\" + roomId)\n            .getOrCreate();\n\n        return actorSystem\n            .get(UserActor.class, \"user-\" + userId)\n            .thenAccept(userActor -&gt; {\n                if (userActor != null) roomTopic.unsubscribe(userActor);\n            });\n    }\n}\n</code></pre> <p>Notes:</p> <ul> <li>Actors must handle the message type published to the topic</li> <li>Actors are automatically unsubscribed when they terminate</li> <li>Duplicate subscriptions are deduplicated</li> </ul>"},{"location":"guides/pub-sub-topics/#usage-patterns","title":"Usage Patterns","text":""},{"location":"guides/pub-sub-topics/#pattern-1-service-managed-topics","title":"Pattern 1: Service-Managed Topics","text":"<p>Cache topic references in services for frequently used topics:</p> <pre><code>@Service\npublic class NotificationService {\n    private final SpringTopicRef&lt;Notification&gt; notificationTopic;\n\n    public NotificationService(SpringTopicManager topicManager) {\n        this.notificationTopic = topicManager\n            .topic(Notification.class)\n            .withName(\"system-notifications\")\n            .getOrCreate();\n    }\n\n    public void broadcast(Notification notification) {\n        notificationTopic.publish(notification);\n    }\n}\n</code></pre>"},{"location":"guides/pub-sub-topics/#pattern-2-actor-managed-topics","title":"Pattern 2: Actor-Managed Topics","text":"<p>Actors can inject <code>SpringTopicManager</code> to manage their own topics:</p> <pre><code>@Component\npublic class ChatRoomActor implements SpringShardedActor&lt;Command&gt; {\n    private final SpringTopicManager topicManager;\n\n    public ChatRoomActor(SpringTopicManager topicManager) {\n        this.topicManager = topicManager;\n    }\n\n    @Override\n    public SpringShardedActorBehavior&lt;Command&gt; create(SpringShardedActorContext&lt;Command&gt; ctx) {\n        String roomId = ctx.getEntityId();\n\n        SpringTopicRef&lt;ChatEvent&gt; roomTopic = topicManager\n            .topic(ChatEvent.class)\n            .withName(\"chat-room-\" + roomId)\n            .getOrCreate();\n\n        return SpringShardedActorBehavior.builder(Command.class, ctx)\n            .withState(behaviorCtx -&gt; new ChatRoomBehavior(behaviorCtx, roomTopic))\n            .onMessage(SendMessage.class, ChatRoomBehavior::onSendMessage)\n            .build();\n    }\n\n    private static class ChatRoomBehavior {\n        private final SpringBehaviorContext&lt;Command&gt; ctx;\n        private final SpringTopicRef&lt;ChatEvent&gt; roomTopic;\n\n        ChatRoomBehavior(SpringBehaviorContext&lt;Command&gt; ctx, SpringTopicRef&lt;ChatEvent&gt; roomTopic) {\n            this.ctx = ctx;\n            this.roomTopic = roomTopic;\n        }\n\n        private Behavior&lt;Command&gt; onSendMessage(SendMessage msg) {\n            roomTopic.publish(new ChatEvent(msg.userId, msg.message));\n            return Behaviors.same();\n        }\n    }\n}\n</code></pre>"},{"location":"guides/pub-sub-topics/#best-practices","title":"Best Practices","text":"<ol> <li>Use <code>getOrCreate()</code> for idempotent topic creation</li> <li>Cache topic references in service fields</li> <li>Use descriptive, hierarchical names (e.g., <code>chat-room-lobby</code>, <code>notifications-user-123</code>)</li> <li>Keep messages immutable and small</li> <li>Use <code>JsonSerializable</code> or <code>CborSerializable</code> for cluster compatibility</li> <li>Don't rely on topics for critical guaranteed-delivery messages</li> </ol> <p>Topic Naming</p> <p>Use hierarchical naming conventions like <code>service-domain-entity</code> to organize topics logically and make debugging easier.</p>"},{"location":"guides/pub-sub-topics/#next-steps","title":"Next Steps","text":"<ul> <li>Sharded Actors - Distributed entity management in clusters</li> <li>Chat Example - Real-world pub/sub usage in a chat application</li> <li>Actor Registration - Core actor concepts and messaging patterns</li> </ul>"},{"location":"guides/routers/","title":"Routers","text":"<p>This guide explains how to use routers to distribute messages across multiple worker actors for load balancing and parallel processing.</p>"},{"location":"guides/routers/#what-are-routers","title":"What are Routers?","text":"<p>A router is a special actor that distributes incoming messages across a pool of worker actors. Instead of sending messages directly to a single actor, you send them to the router, which forwards them to one of its workers based on a routing strategy.</p> <p>Routers are ideal for:</p> <ul> <li>Load balancing - Distributing work evenly across multiple workers</li> <li>Parallel processing - Processing messages concurrently</li> <li>Scalability - Easily scale by increasing the pool size</li> <li>Fault tolerance - Worker failures don't affect the router</li> </ul>"},{"location":"guides/routers/#creating-a-router","title":"Creating a Router","text":""},{"location":"guides/routers/#define-your-worker-actor","title":"Define Your Worker Actor","text":"<p>First, create a worker actor that will process messages:</p> <pre><code>@Component\npublic class WorkerActor implements SpringActor&lt;ProcessorRouter.Command&gt; {\n\n    @Autowired\n    private WorkerState state;\n\n    @Override\n    public SpringActorBehavior&lt;ProcessorRouter.Command&gt; create(SpringActorContext ctx) {\n        return SpringActorBehavior.builder(ProcessorRouter.Command.class, ctx)\n            .onMessage(ProcessorRouter.ProcessMessage.class, (context, msg) -&gt; {\n                // Process the message\n                String result = processData(msg.data);\n                context.getLog().info(\"Processed: {}\", result);\n                return Behaviors.same();\n            })\n            .build();\n    }\n\n    private String processData(String data) {\n        // Your processing logic here\n        return \"Processed: \" + data;\n    }\n}\n</code></pre>"},{"location":"guides/routers/#create-the-router-actor","title":"Create the Router Actor","text":"<p>Create a router actor that uses <code>SpringRouterBehavior</code>:</p> <pre><code>@Component\npublic class ProcessorRouter implements SpringActor&lt;ProcessorRouter.Command&gt; {\n\n    public interface Command {}\n\n    public static class ProcessMessage implements Command {\n        public final String data;\n\n        public ProcessMessage(String data) {\n            this.data = data;\n        }\n    }\n\n    @Override\n    public SpringActorBehavior&lt;Command&gt; create(SpringActorContext ctx) {\n        return SpringRouterBehavior.builder(Command.class, ctx)\n            .withRoutingStrategy(RoutingStrategy.roundRobin())\n            .withPoolSize(10)  // 10 worker actors\n            .withWorkerActors(WorkerActor.class)\n            .build();\n    }\n}\n</code></pre>"},{"location":"guides/routers/#use-the-router","title":"Use the Router","text":"<p>Spawn and use the router like any other actor:</p> <pre><code>@Service\npublic class ProcessingService {\n    private final SpringActorSystem actorSystem;\n\n    public ProcessingService(SpringActorSystem actorSystem) {\n        this.actorSystem = actorSystem;\n    }\n\n    public void processData(String data) {\n        actorSystem.getOrSpawn(ProcessorRouter.class, \"processor\")\n            .thenAccept(router -&gt;\n                router.tell(new ProcessorRouter.ProcessMessage(data))\n            );\n    }\n}\n</code></pre>"},{"location":"guides/routers/#routing-strategies","title":"Routing Strategies","text":"<p>Spring Boot Starter Actor provides four routing strategies, all wrapping Apache Pekko's built-in routers.</p>"},{"location":"guides/routers/#round-robin","title":"Round Robin","text":"<p>Distributes messages evenly across workers in a circular fashion. This is the default and most commonly used strategy.</p> <pre><code>return SpringRouterBehavior.builder(Command.class, ctx)\n    .withRoutingStrategy(RoutingStrategy.roundRobin())\n    .withPoolSize(5)\n    .withWorkerActors(WorkerActor.class)\n    .build();\n</code></pre> <p>Message distribution:</p> <ul> <li>Message 1 \u2192 Worker 1</li> <li>Message 2 \u2192 Worker 2</li> <li>Message 3 \u2192 Worker 3</li> <li>Message 4 \u2192 Worker 1 (cycles back)</li> </ul> <p>Best for:</p> <ul> <li>Equal distribution of work</li> <li>Predictable load balancing</li> <li>Tasks with similar processing time</li> </ul>"},{"location":"guides/routers/#random","title":"Random","text":"<p>Distributes messages randomly across workers. Very lightweight with no state tracking.</p> <pre><code>return SpringRouterBehavior.builder(Command.class, ctx)\n    .withRoutingStrategy(RoutingStrategy.random())\n    .withPoolSize(5)\n    .withWorkerActors(WorkerActor.class)\n    .build();\n</code></pre> <p>Best for:</p> <ul> <li>Simple distribution without state tracking</li> <li>Non-critical workloads</li> <li>Avoiding ordering effects</li> </ul>"},{"location":"guides/routers/#broadcast","title":"Broadcast","text":"<p>Sends all messages to all workers. Each worker receives every message.</p> <pre><code>return SpringRouterBehavior.builder(Command.class, ctx)\n    .withRoutingStrategy(RoutingStrategy.broadcast())\n    .withPoolSize(3)\n    .withWorkerActors(CacheActor.class)\n    .build();\n</code></pre> <p>Message Multiplication</p> <p>Message volume increases by pool size factor (10 messages \u00d7 5 workers = 50 total messages processed).</p> <p>Best for:</p> <ul> <li>Cache invalidation across all workers</li> <li>Configuration updates</li> <li>Notifications that all workers need to receive</li> <li>Coordinated state updates</li> </ul> <p>Performance Impact</p> <p>Use sparingly for high-volume systems due to the message multiplication effect.</p>"},{"location":"guides/routers/#consistent-hashing","title":"Consistent Hashing","text":"<p>Routes messages with the same hash key to the same worker, enabling session affinity and stateful processing.</p>"},{"location":"guides/routers/#messages-with-consistenthashable","title":"Messages with ConsistentHashable","text":"<p>Implement the <code>ConsistentHashable</code> interface for explicit hash keys:</p> <pre><code>public static class ProcessOrder implements Command, ConsistentHashable {\n    private final String customerId;\n    private final String orderId;\n\n    public ProcessOrder(String customerId, String orderId) {\n        this.customerId = customerId;\n        this.orderId = orderId;\n    }\n\n    @Override\n    public String getConsistentHashKey() {\n        return customerId;  // Same customer always goes to same worker\n    }\n}\n</code></pre>"},{"location":"guides/routers/#create-consistent-hashing-router","title":"Create Consistent Hashing Router","text":"<pre><code>return SpringRouterBehavior.builder(Command.class, ctx)\n    .withRoutingStrategy(RoutingStrategy.consistentHashing())\n    .withPoolSize(10)\n    .withWorkerActors(OrderWorkerActor.class)\n    .build();\n</code></pre> <p>With custom virtual nodes factor:</p> <pre><code>// Higher virtual nodes = better distribution but more memory\n.withRoutingStrategy(RoutingStrategy.consistentHashing(20))\n</code></pre> <p>Virtual nodes factor (default: 10): - Higher values (10-20) = better distribution, more memory - Lower values (1-5) = less memory, potential hotspots</p> <p>Messages without ConsistentHashable:</p> <p>If your message doesn't implement <code>ConsistentHashable</code>, the router uses <code>toString()</code> as the hash key.</p> <p>Best for:</p> <ul> <li>User session management (same userId \u2192 same worker)</li> <li>Entity-based processing (same orderId \u2192 same worker)</li> <li>Stateful message processing</li> <li>Cache locality optimization</li> </ul>"},{"location":"guides/routers/#worker-supervision","title":"Worker Supervision","text":"<p>Configure how workers are supervised when they fail:</p> <pre><code>return SpringRouterBehavior.builder(Command.class, ctx)\n    .withRoutingStrategy(RoutingStrategy.roundRobin())\n    .withPoolSize(10)\n    .withWorkerActors(WorkerActor.class)\n    .withSupervisionStrategy(SupervisorStrategy.restart())  // Restart failed workers\n    .build();\n</code></pre> <p>Available strategies:</p> <ul> <li><code>restart()</code> - Restart the worker (default)</li> <li><code>stop()</code> - Stop the worker permanently</li> <li><code>resume()</code> - Resume processing, ignoring the failure</li> </ul> <p>With limits:</p> <pre><code>// Restart up to 3 times within 1 minute, then stop\n.withSupervisionStrategy(\n    SupervisorStrategy.restart().withLimit(3, Duration.ofMinutes(1))\n)\n</code></pre>"},{"location":"guides/routers/#spring-dependency-injection-in-workers","title":"Spring Dependency Injection in Workers","text":"<p>Worker actors are full Spring components with dependency injection support:</p> <pre><code>@Component\npublic class DatabaseWorkerActor implements SpringActor&lt;Command&gt; {\n\n    @Autowired\n    private DatabaseService databaseService;  // Spring DI!\n\n    @Autowired\n    private MetricsService metricsService;    // Spring DI!\n\n    @Override\n    public SpringActorBehavior&lt;Command&gt; create(SpringActorContext ctx) {\n        return SpringActorBehavior.builder(Command.class, ctx)\n            .onMessage(SaveData.class, (context, msg) -&gt; {\n                // Use injected Spring beans\n                databaseService.save(msg.data);\n                metricsService.recordSave();\n                return Behaviors.same();\n            })\n            .build();\n    }\n}\n</code></pre> <p>All workers in the pool share the same Spring bean instances (singletons), enabling: - Shared caching - Connection pooling - Centralized metrics</p>"},{"location":"guides/routers/#ask-pattern-with-routers","title":"Ask Pattern with Routers","text":"<p>Routers support the ask pattern for request-response messaging:</p> <pre><code>@Component\npublic class ValidationRouter implements SpringActor&lt;ValidationRouter.Command&gt; {\n\n    public interface Command {}\n\n    public static class ValidateData extends AskCommand&lt;Boolean&gt; implements Command {\n        public final String data;\n\n        public ValidateData(String data) {\n            this.data = data;\n        }\n    }\n\n    @Override\n    public SpringActorBehavior&lt;Command&gt; create(SpringActorContext ctx) {\n        return SpringRouterBehavior.builder(Command.class, ctx)\n            .withRoutingStrategy(RoutingStrategy.roundRobin())\n            .withPoolSize(5)\n            .withWorkerActors(ValidationWorkerActor.class)\n            .build();\n    }\n}\n</code></pre> <p>Using ask pattern:</p> <pre><code>public Mono&lt;Boolean&gt; validateData(String data) {\n    return Mono.fromCompletionStage(\n        actorSystem.getOrSpawn(ValidationRouter.class, \"validator\")\n            .thenCompose(router -&gt;\n                router.ask(new ValidationRouter.ValidateData(data))\n                    .withTimeout(Duration.ofSeconds(5))\n                    .execute()\n            )\n    );\n}\n</code></pre>"},{"location":"guides/routers/#complete-example","title":"Complete Example","text":"<p>Here's a complete example of a processing pipeline with routers:</p> <pre><code>// Worker actor\n@Component\npublic class OrderProcessorWorker implements SpringActor&lt;OrderRouter.Command&gt; {\n\n    @Autowired\n    private OrderService orderService;\n\n    @Override\n    public SpringActorBehavior&lt;OrderRouter.Command&gt; create(SpringActorContext ctx) {\n        return SpringActorBehavior.builder(OrderRouter.Command.class, ctx)\n            .onMessage(OrderRouter.ProcessOrder.class, (context, msg) -&gt; {\n                orderService.processOrder(msg.orderId, msg.customerId);\n                context.getLog().info(\"Processed order {} for customer {}\",\n                    msg.orderId, msg.customerId);\n                return Behaviors.same();\n            })\n            .build();\n    }\n}\n\n// Router actor with consistent hashing\n@Component\npublic class OrderRouter implements SpringActor&lt;OrderRouter.Command&gt; {\n\n    public interface Command {}\n\n    public static class ProcessOrder implements Command, ConsistentHashable {\n        public final String orderId;\n        public final String customerId;\n\n        public ProcessOrder(String orderId, String customerId) {\n            this.orderId = orderId;\n            this.customerId = customerId;\n        }\n\n        @Override\n        public String getConsistentHashKey() {\n            return customerId;  // Same customer always goes to same worker\n        }\n    }\n\n    @Override\n    public SpringActorBehavior&lt;Command&gt; create(SpringActorContext ctx) {\n        return SpringRouterBehavior.builder(Command.class, ctx)\n            .withRoutingStrategy(RoutingStrategy.consistentHashing())\n            .withPoolSize(10)\n            .withWorkerActors(OrderProcessorWorker.class)\n            .withSupervisionStrategy(SupervisorStrategy.restart())\n            .build();\n    }\n}\n\n// Service using the router\n@Service\npublic class OrderService {\n    private final SpringActorSystem actorSystem;\n\n    public OrderService(SpringActorSystem actorSystem) {\n        this.actorSystem = actorSystem;\n    }\n\n    public void processOrder(String orderId, String customerId) {\n        actorSystem.getOrSpawn(OrderRouter.class, \"order-processor\")\n            .thenAccept(router -&gt;\n                router.tell(new OrderRouter.ProcessOrder(orderId, customerId))\n            );\n    }\n}\n</code></pre>"},{"location":"guides/routers/#more-information","title":"More Information","text":"<p>For more details about Pekko routers, see the Pekko Typed Routers Documentation.</p>"},{"location":"guides/routers/#next-steps","title":"Next Steps","text":"<ul> <li>Dispatchers - Configure thread execution for your actors</li> <li>Actor Registration - Learn how to create and spawn actors</li> <li>Sharded Actors - Distributed entity management in clusters</li> </ul>"},{"location":"guides/sharded-actors/","title":"Sharded Actors","text":"<p>This guide explains how to create and use sharded actors in a clustered environment using Spring Boot Starter Actor.</p>"},{"location":"guides/sharded-actors/#what-are-sharded-actors","title":"What are Sharded Actors?","text":"<p>Sharded actors are actors that are distributed across multiple nodes in a cluster. Each actor instance (entity) is responsible for a specific entity ID, and the cluster ensures that only one instance of an entity exists across the entire cluster at any given time.</p> <p>Sharding is useful when:</p> <ul> <li>You need to distribute actor instances across multiple nodes</li> <li>You have a large number of actors that would be too much for a single node</li> <li>You want automatic rebalancing of actors when nodes join or leave the cluster</li> </ul> <p>Cluster Sharding</p> <p>Cluster sharding provides location transparency - you can send messages to entities without knowing which node they're on.</p>"},{"location":"guides/sharded-actors/#setting-up-a-cluster","title":"Setting Up a Cluster","text":"<p>Before you can use sharded actors, you need to set up a Pekko cluster. Add the following configuration to your <code>application.yml</code> file:</p> <pre><code>spring:\n  application:\n    name: spring-pekko\n  actor:\n    pekko:\n      name: spring-pekko-example\n      actor:\n        provider: cluster\n        allow-java-serialization: off\n        warn-about-java-serializer-usage: on\n      remote:\n        artery:\n          canonical:\n            hostname: 127.0.0.1\n            port: 2551\n      cluster:\n        name: spring-pekko-example\n        seed-nodes:\n          - pekko://spring-pekko-example@127.0.0.1:2551\n          - pekko://spring-pekko-example@127.0.0.1:2552\n          - pekko://spring-pekko-example@127.0.0.1:2553\n        downing-provider-class: org.apache.pekko.cluster.sbr.SplitBrainResolverProvider\n\nserver:\n  port: 8080\n</code></pre> <p>Configuration Notes</p> <ul> <li>Adjust the hostname, port, and seed-nodes according to your environment</li> <li>For production, use proper hostnames and DNS instead of localhost</li> <li>The downing provider handles split-brain scenarios</li> </ul>"},{"location":"guides/sharded-actors/#creating-a-sharded-actor","title":"Creating a Sharded Actor","text":"<p>To create a sharded actor, implement the <code>SpringShardedActor</code> interface and annotate the class with <code>@Component</code>:</p> <pre><code>@Component\npublic class HelloActor implements SpringShardedActor&lt;HelloActor.Command&gt; {\n\n    public static final EntityTypeKey&lt;Command&gt; TYPE_KEY =\n            EntityTypeKey.create(Command.class, \"HelloActor\");\n\n    // Define the command interface for messages this actor can handle\n    public interface Command extends JsonSerializable {}\n\n    // Define a message type\n    public static class SayHello extends AskCommand&lt;String&gt; implements Command {\n        public final String message;\n\n        public SayHello(String message) {\n            this.message = message;\n        }\n    }\n\n    @Override\n    public EntityTypeKey&lt;Command&gt; typeKey() {\n        return TYPE_KEY;\n    }\n\n    @Override\n    public SpringShardedActorBehavior&lt;Command&gt; create(SpringShardedActorContext&lt;Command&gt; ctx) {\n        final String entityId = ctx.getEntityId();\n\n        return SpringShardedActorBehavior.builder(Command.class, ctx)\n                .withState(actorCtx -&gt; new HelloActorBehavior(actorCtx, entityId))\n                .onMessage(SayHello.class, HelloActorBehavior::onSayHello)\n                .build();\n    }\n\n    /**\n     * Behavior handler for hello actor. Holds the entity ID and handles messages.\n     */\n    private static class HelloActorBehavior {\n        private final ActorContext&lt;Command&gt; ctx;\n        private final String entityId;\n\n        HelloActorBehavior(ActorContext&lt;Command&gt; ctx, String entityId) {\n            this.ctx = ctx;\n            this.entityId = entityId;\n        }\n\n        /**\n         * Handles SayHello commands by responding with node and entity information.\n         *\n         * @param msg The SayHello message\n         * @return The next behavior (same in this case)\n         */\n        private Behavior&lt;Command&gt; onSayHello(SayHello msg) {\n            // Get information about the current node and entity\n            final String nodeAddress = ctx.getSystem().address().toString();\n\n            // Create a response message with node and entity information\n            final String message = \"Received from entity [\" + entityId + \"] on node [\" + nodeAddress + \"]\";\n\n            // Send the response back to the caller\n            msg.reply(message);\n\n            // Log the message for debugging\n            ctx.getLog().info(message);\n\n            return Behaviors.same();\n        }\n    }\n\n    @Override\n    public ShardingMessageExtractor&lt;ShardEnvelope&lt;Command&gt;, Command&gt; extractor() {\n        return new DefaultShardingMessageExtractor&lt;&gt;(3);\n    }\n}\n</code></pre> <p>Key differences from a regular actor:</p> <ol> <li>Implement <code>SpringShardedActor&lt;T&gt;</code> instead of <code>SpringActor&lt;T&gt;</code></li> <li>Commands must implement <code>JsonSerializable</code> (or <code>CborSerializable</code>) for serialization across the network</li> <li>Define an <code>EntityTypeKey</code> for the actor type</li> <li>Override <code>typeKey()</code> to return the EntityTypeKey</li> <li>Override <code>create(SpringShardedActorContext&lt;T&gt;)</code> to return <code>SpringShardedActorBehavior&lt;T&gt;</code> instead of <code>SpringActorBehavior&lt;T&gt;</code></li> <li>Use <code>SpringShardedActorBehavior.builder()</code> instead of <code>SpringActorBehavior.builder()</code></li> <li>Override <code>extractor()</code> to provide a sharding message extractor</li> </ol> <p>Serialization</p> <p>Always use <code>JsonSerializable</code> or <code>CborSerializable</code> for sharded actor messages to ensure they can be sent across the cluster.</p>"},{"location":"guides/sharded-actors/#interacting-with-sharded-actors","title":"Interacting with Sharded Actors","text":"<p>To interact with sharded actors, you use the <code>sharded</code> method of the <code>SpringActorSystem</code>:</p> <pre><code>@Service\npublic class HelloService {\n\n    private final SpringActorSystem springActorSystem;\n\n    public HelloService(SpringActorSystem springActorSystem) {\n        this.springActorSystem = springActorSystem;\n    }\n\n    /**\n     * Best practice for sharded actors:\n     * - Get reference on each request (references are lightweight)\n     * - No need to cache (entities are managed by cluster sharding)\n     * - No need to check existence (entities are created on-demand)\n     * - Use ask for timeout and error handling\n     */\n    public Mono&lt;String&gt; hello(String message, String entityId) {\n        // Get a reference to the sharded actor entity\n        SpringShardedActorHandle&lt;HelloActor.Command&gt; actorRef =\n                springActorSystem.sharded(HelloActor.class).withId(entityId).get();\n\n        // Send the message using the fluent ask builder with timeout and error handling\n        CompletionStage&lt;String&gt; response = actorRef\n                .ask(new HelloActor.SayHello(message))\n                .withTimeout(Duration.ofSeconds(3))\n                .onTimeout(() -&gt; \"Request timed out for entity: \" + entityId)\n                .execute();\n\n        // Convert the CompletionStage to a Mono for reactive programming\n        return Mono.fromCompletionStage(response);\n    }\n}\n</code></pre> <p>The <code>sharded</code> method creates a builder that:</p> <ol> <li>Takes the actor class as a parameter</li> <li>Requires setting the entity ID using <code>withId()</code></li> <li>Returns the actor reference with <code>get()</code></li> </ol> <p>The builder pattern provides a more fluent API and automatically resolves the <code>EntityTypeKey</code> from the actor class.</p>"},{"location":"guides/sharded-actors/#key-differences-from-regular-actors","title":"Key Differences from Regular Actors","text":"<p>Sharded actors behave differently from regular actors:</p> <ol> <li>No <code>start()</code> needed: Entities are created automatically when the first message arrives</li> <li>Always available: Entity references are always valid, even if the entity isn't currently running</li> <li>Auto-distribution: Entities are automatically distributed across cluster nodes</li> <li>Auto-passivation: Entities are automatically stopped after idle timeout (configurable)</li> <li>Lightweight references: Getting a reference doesn't create the entity, so no caching needed</li> <li>No exists/get checks: The cluster sharding coordinator manages entity lifecycle</li> </ol> <p>Example - Regular Actor vs Sharded Actor:</p> <pre><code>// Regular Actor - needs explicit lifecycle management\nCompletionStage&lt;SpringActorHandle&lt;Command&gt;&gt; actor = actorSystem\n    .exists(MyActor.class, \"actor-1\")\n    .thenCompose(exists -&gt; {\n        if (exists) {\n            return actorSystem.get(MyActor.class, \"actor-1\");\n        } else {\n            return actorSystem.actor(MyActor.class)\n                .withId(\"actor-1\")\n                .spawn();\n        }\n    });\n\n// Sharded Actor - just get the reference and use it\nSpringShardedActorHandle&lt;Command&gt; actor = actorSystem\n    .sharded(MyShardedActor.class)\n    .withId(\"actor-1\")\n    .get();\n</code></pre> <p>Automatic Lifecycle</p> <p>Sharded actors don't require explicit <code>start()</code> or lifecycle management. Simply get a reference and send messages - the entity is created automatically on first message.</p>"},{"location":"guides/sharded-actors/#using-sharded-actors-in-a-rest-controller","title":"Using Sharded Actors in a REST Controller","text":"<p>Here's an example of how to use the sharded actor service in a REST controller:</p> <pre><code>@RestController\npublic class HelloController {\n\n    private final HelloService helloService;\n\n    public HelloController(HelloService helloService) {\n        this.helloService = helloService;\n    }\n\n    @GetMapping(\"/hello\")\n    public Mono&lt;String&gt; hello(@RequestParam String message, @RequestParam String entityId) {\n        return helloService.hello(message, entityId);\n    }\n}\n</code></pre>"},{"location":"guides/sharded-actors/#entity-id-strategies","title":"Entity ID Strategies","text":"<p>The entity ID is a crucial part of sharding. It determines which shard an entity belongs to, and therefore which node in the cluster will host the entity.</p> <p>Common strategies for choosing entity IDs:</p> <ol> <li>Natural Keys - Use existing business identifiers (e.g., user IDs, order numbers)</li> <li>Composite Keys - Combine multiple fields to form a unique identifier</li> <li>Hash-Based Keys - Generate a hash from the entity's data</li> <li>UUID - Generate a random UUID for each entity</li> </ol> <p>ID Selection</p> <p>Choose a strategy that ensures even distribution of entities across shards while maintaining the ability to locate entities when needed.</p>"},{"location":"guides/sharded-actors/#sharding-configuration","title":"Sharding Configuration","text":"<p>You can configure sharding behavior using the <code>extractor()</code> method in your sharded actor:</p> <pre><code>@Override\npublic ShardingMessageExtractor&lt;ShardEnvelope&lt;Command&gt;, Command&gt; extractor() {\n    return new DefaultShardingMessageExtractor&lt;&gt;(numberOfShards);\n}\n</code></pre> <p>The <code>DefaultShardingMessageExtractor</code> takes a parameter that specifies the number of shards to use. More shards allow for finer-grained distribution but increase overhead.</p>"},{"location":"guides/sharded-actors/#best-practices-for-sharded-actors","title":"Best Practices for Sharded Actors","text":"<ol> <li>Don't Cache References - Get references on each request; they're lightweight and don't create entities</li> <li>Use ask - Always use <code>ask()</code> with timeout and error handling for production code</li> <li>Design for Idempotency - Messages may be redelivered during rebalancing, so design handlers to be idempotent</li> <li>Choose Entity IDs Wisely - Use natural business keys for even distribution across shards</li> <li>Avoid Cross-Entity Dependencies - Minimize communication between entities to reduce network overhead</li> <li>Monitor Shard Distribution - Use built-in metrics to ensure entities are evenly distributed</li> <li>Configure Passivation - Tune idle timeout based on your use case to balance memory and startup costs</li> <li>Use JSON Serialization - Prefer <code>JsonSerializable</code> over Java serialization for better performance and compatibility</li> </ol> <p>Cross-Entity Communication</p> <p>Minimize dependencies between sharded entities. Each cross-entity message incurs network overhead and can impact performance.</p>"},{"location":"guides/sharded-actors/#comparison-regular-vs-sharded-actors","title":"Comparison: Regular vs Sharded Actors","text":"Feature Regular Actor Sharded Actor Lifecycle Manual (spawn/start/stop) Automatic (on-demand) Distribution Single node Distributed across cluster Reference Creation Heavy (creates actor) Lightweight (just reference) Caching Required for performance Not needed Existence Check Use <code>exists()</code> Not needed Serialization Not required Required (<code>JsonSerializable</code>) Use Case Local, long-lived actors Distributed, large-scale entities"},{"location":"guides/sharded-actors/#next-steps","title":"Next Steps","text":"<p>Now that you know how to create and use sharded actors, you can:</p> <ol> <li>Explore the Cluster Example - See sharded actors in action</li> <li>Learn about Persistence - Add state persistence to your actors</li> <li>Set up Monitoring - Track cluster health and performance</li> </ol>"}]}