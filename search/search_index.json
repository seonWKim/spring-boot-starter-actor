{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Spring Boot Starter Actor","text":"<p>A library that integrates Spring Boot with the actor model using Pekko (an open-source, community-driven fork of Akka).</p>"},{"location":"#what-is-this-project-about","title":"What is this project about?","text":"<p>This project bridges the gap between Spring Boot and the actor model, allowing developers to integrate actors to their applications using familiar Spring Boot patterns with ease.</p>"},{"location":"#why","title":"Why?","text":"<p>Many use Java with Spring (usually Spring Boot). Modern programming guides recommend building stateless architectures. But sometimes, stateful features are needed, such as in chat applications where the server needs to know where clients in the same chatroom are located.</p> <p>The actor model is a well-known programming model suited for stateful applications:</p> <ul> <li>Encapsulate logic into actors</li> <li>Communicate by sending messages between them</li> </ul> <p>This project aims to bring together the best of both worlds:</p> <ul> <li>Spring Boot's ease of use and extensive ecosystem</li> <li>The actor model's natural approach to encapsulation and state management</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Auto-configure Pekko with Spring Boot</li> <li>Seamless integration with Spring's dependency injection</li> <li>Support for both local and cluster modes</li> <li>Easy actor creation and management</li> <li>Spring-friendly actor references</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Check out the Getting Started guide to begin using Spring Boot Starter Actor in your projects.</p>"},{"location":"#examples","title":"Examples","text":"<p>Explore our example applications to see Spring Boot Starter Actor in action:</p> <ul> <li>Simple Example: Demonstrates basic actor usage in a non-clustered environment</li> <li>Cluster Example: Shows how to use sharded actors in a clustered environment</li> <li>Chat Example: A complete chat application using actors</li> <li>Synchronization Example: Demonstrates synchronization patterns with actors</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>This page provides a reference for the key interfaces and classes in Spring Boot Starter Actor.</p>"},{"location":"api-reference/#core-interfaces","title":"Core Interfaces","text":""},{"location":"api-reference/#springactor","title":"SpringActor","text":"<p>The <code>SpringActor</code> interface is the base interface for all actors in Spring Boot Starter Actor. It defines the contract for creating actors that can be managed by Spring.</p> <pre><code>public interface SpringActor&lt;A extends SpringActor&lt;A, C&gt;, C&gt; {\n    /**\n     * Creates a behavior for this actor. This method is called by the actor system when a new actor\n     * is created.\n     *\n     * @param actorContext The context of the actor\n     * @return A behavior for the actor\n     */\n    Behavior&lt;C&gt; create(SpringActorContext actorContext);\n}\n</code></pre>"},{"location":"api-reference/#shardedactor","title":"ShardedActor","text":"<p>The <code>ShardedActor</code> interface provides support for sharding actors across a cluster.</p> <pre><code>public interface ShardedActor&lt;T&gt; {\n    /**\n     * Returns the entity type key for this actor type. The entity type key is used to identify the\n     * actor type in the cluster.\n     *\n     * @return The entity type key for this actor type\n     */\n    EntityTypeKey&lt;T&gt; typeKey();\n\n    /**\n     * Creates a behavior for the actor given an entity context. This method is called when a new\n     * instance of the actor is created.\n     *\n     * @param ctx The entity context for the actor\n     * @return A behavior for the actor\n     */\n    Behavior&lt;T&gt; create(EntityContext&lt;T&gt; ctx);\n\n    /**\n     * Returns a message extractor for this actor type. The message extractor is used to extract\n     * entity IDs and shard IDs from messages.\n     *\n     * @return A message extractor for this actor type\n     */\n    ShardingMessageExtractor&lt;ShardEnvelope&lt;T&gt;, T&gt; extractor();\n}\n</code></pre>"},{"location":"api-reference/#core-classes","title":"Core Classes","text":""},{"location":"api-reference/#springactorsystem","title":"SpringActorSystem","text":"<p>The <code>SpringActorSystem</code> class is the main entry point for interacting with actors. It provides methods for spawning actors and getting references to sharded actors.</p> <pre><code>public class SpringActorSystem {\n    /**\n     * Spawns an actor with the given spawn context.\n     *\n     * @param spawnContext The context containing all parameters needed to spawn the actor\n     * @return A CompletionStage that resolves to a reference to the spawned actor\n     */\n    public &lt;A extends SpringActor&lt;A, T&gt;, T&gt; CompletionStage&lt;SpringActorRef&lt;T&gt;&gt; spawn(SpringActorSpawnContext&lt;A, T&gt; spawnContext);\n\n    /**\n     * Asynchronously stops a previously spawned actor with the given stop context.\n     *\n     * @param stopContext The context containing all parameters needed to stop the actor\n     * @return A CompletionStage that completes when the stop command has been processed\n     */\n    public &lt;A extends SpringActor&lt;A, C&gt;, C&gt; CompletionStage&lt;StopResult&gt; stop(SpringActorStopContext&lt;A, C&gt; stopContext);\n\n    /**\n     * Creates a fluent builder for getting a reference to a sharded actor.\n     *\n     * @param actorClass The class of the sharded actor\n     * @return A builder for configuring and getting the sharded actor reference\n     */\n    public &lt;T&gt; SpringShardedActorBuilder&lt;T&gt; sharded(Class&lt;? extends ShardedActor&lt;T&gt;&gt; actorClass);\n}\n</code></pre>"},{"location":"api-reference/#springactorref","title":"SpringActorRef","text":"<p>The <code>SpringActorRef</code> class represents a reference to an actor. It provides methods for sending messages to the actor.</p> <pre><code>public class SpringActorRef&lt;T&gt; {\n    /**\n     * Sends a message to the actor and expects a response.\n     *\n     * @param messageFactory A function that creates the message, given a reply-to actor reference\n     * @param timeout The timeout for the ask operation\n     * @return A CompletionStage that resolves to the response from the actor\n     */\n    public &lt;R&gt; CompletionStage&lt;R&gt; ask(\n            Function&lt;ActorRef&lt;R&gt;, T&gt; messageFactory, Duration timeout);\n\n    /**\n     * Sends a message to the actor without expecting a response.\n     *\n     * @param message The message to send\n     */\n    public void tell(T message);\n}\n</code></pre>"},{"location":"api-reference/#springshardedactorref","title":"SpringShardedActorRef","text":"<p>The <code>SpringShardedActorRef</code> class represents a reference to a sharded actor entity. It provides methods for sending messages to the entity.</p> <pre><code>public class SpringShardedActorRef&lt;T&gt; {\n    /**\n     * Sends a message to the entity and expects a response.\n     *\n     * @param messageFactory A function that creates the message, given a reply-to actor reference\n     * @param timeout The timeout for the ask operation\n     * @return A CompletionStage that resolves to the response from the entity\n     */\n    public &lt;R&gt; CompletionStage&lt;R&gt; ask(\n            Function&lt;ActorRef&lt;R&gt;, T&gt; messageFactory, Duration timeout);\n\n    /**\n     * Sends a message to the entity without expecting a response.\n     *\n     * @param message The message to send\n     */\n    public void tell(T message);\n}\n</code></pre>"},{"location":"api-reference/#serialization","title":"Serialization","text":"<p>Refer to <code>JsonSerializable</code> or <code>CborSerializable</code>.</p>"},{"location":"getting-started/","title":"Getting Started with Spring Boot Starter Actor","text":"<p>This guide will help you get started with Spring Boot Starter Actor in your Spring Boot application.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Java 11 or higher</li> <li>Spring Boot 2.x or 3.x</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Add the dependency to your project:</p> <pre><code>// Manually overwrite spring managed jackson dependency \ndependencyManagement {\n    imports {\n        // require minimum 2.17.3 version of jackson\n        mavenBom(\"com.fasterxml.jackson:jackson-bom:2.17.3\")\n    }\n}\n\n// Gradle(spring boot 2.7.x)\nimplementation 'io.github.seonwkim:spring-boot-starter-actor:0.1.0'\n\n// Gradle(spring boot 3.2.x)\nimplementation 'io.github.seonwkim:spring-boot-starter-actor_3:0.1.0'\n</code></pre> <pre><code>&lt;dependencyManagement&gt;\n  &lt;dependencies&gt;\n    &lt;!-- Override Spring Boot's jackson-bom with 2.17.3 --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;com.fasterxml.jackson&lt;/groupId&gt;\n      &lt;artifactId&gt;jackson-bom&lt;/artifactId&gt;\n      &lt;version&gt;2.17.3&lt;/version&gt;\n      &lt;type&gt;pom&lt;/type&gt;\n      &lt;scope&gt;import&lt;/scope&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n\n&lt;!-- Maven(spring boot 2.7.x) --&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;io.github.seonwkim&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter-actor&lt;/artifactId&gt;\n  &lt;version&gt;0.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;!-- Maven(spring boot 3.2.x) --&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;io.github.seonwkim&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter-actor_3&lt;/artifactId&gt;\n  &lt;version&gt;0.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>To view the latest versions, refer to the following: - spring-boot-starter-actor - spring-boot-starter-actor_3</p>"},{"location":"getting-started/#basic-configuration","title":"Basic Configuration","text":"<p>Spring Boot Starter Actor uses Spring Boot's auto-configuration to set up the actor system. By default, it will create a local actor system with sensible defaults.</p>"},{"location":"getting-started/#enable-actor-support","title":"Enable Actor Support","text":"<p>Add the <code>@EnableActorSupport</code> annotation to your Spring Boot application class:</p> <pre><code>@SpringBootApplication\n@EnableActorSupport\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n</code></pre>"},{"location":"getting-started/#application-properties","title":"Application Properties","text":"<p>You can customize the actor system using application properties (or yaml):</p> <pre><code># application.properties or application.yml\nspring:\n  application:\n    name: spring-pekko\n  actor:\n    pekko:\n      actor:\n        provider: local\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have set up Spring Boot Starter Actor in your project, you can:</p> <ol> <li>Learn how to register actors and send messages</li> <li>Create sharded actors for clustered environments</li> <li>Explore the API Reference for detailed information about the library's APIs</li> </ol>"},{"location":"examples/","title":"Spring Boot Starter Actor Examples","text":"<p>Welcome to the Spring Boot Starter Actor examples documentation. This documentation provides detailed explanations of the example projects included in the repository, demonstrating various features and use cases of the Spring Boot Starter Actor library.</p>"},{"location":"examples/#overview","title":"Overview","text":"<p>Spring Boot Starter Actor is a library that integrates the Apache Pekko (formerly Akka) actor model with Spring Boot, making it easy to use actors in your Spring applications. The actor model provides a powerful approach to building concurrent, distributed, and resilient applications.</p> <p>These examples demonstrate how to use Spring Boot Starter Actor in different scenarios, from simple applications to complex, real-world use cases.</p>"},{"location":"examples/#available-examples","title":"Available Examples","text":""},{"location":"examples/#simple-example","title":"Simple Example","text":"<p>The Simple Example demonstrates the basic usage of Spring Boot Starter Actor in a non-clustered environment. It shows how to:</p> <ul> <li>Create and register actors in a Spring Boot application</li> <li>Send messages to actors and receive responses</li> <li>Integrate actors with a REST API</li> </ul> <p>This is a great starting point for understanding the core concepts of the library.</p>"},{"location":"examples/#cluster-example","title":"Cluster Example","text":"<p>The Cluster Example shows how to use Spring Boot Starter Actor in a clustered environment, focusing on how entities can be easily used with the library. It demonstrates:</p> <ul> <li>Creating and using sharded actors across a cluster</li> <li>Distributing actor instances across multiple nodes</li> <li>Sending messages to specific entity instances</li> <li>Handling entity state in a distributed environment</li> </ul>"},{"location":"examples/#synchronization-example","title":"Synchronization Example","text":"<p>The Synchronization Example demonstrates how to implement efficient synchronization using Spring Boot Starter Actor, comparing it with traditional synchronization approaches. It shows:</p> <ul> <li>Implementing counters with different synchronization mechanisms</li> <li>Comparing database locking, Redis locking, and actor-based synchronization</li> <li>Handling concurrent access to shared resources</li> <li>Achieving high performance with actor-based synchronization</li> </ul> <p>This example explains why using actors for synchronization is cheap and efficient compared to other approaches.</p>"},{"location":"examples/#chat-example","title":"Chat Example","text":"<p>The Chat Example demonstrates how to build a real-time chat application using Spring Boot Starter Actor without introducing third-party middleware. It shows:</p> <ul> <li>Building a real-time chat application using actors</li> <li>Implementing WebSocket communication for real-time messaging</li> <li>Creating a scalable, clustered chat system</li> <li>Eliminating the need for external message brokers or middleware</li> </ul> <p>This example demonstrates how Spring Boot Starter Actor can be used to build real-world applications efficiently without relying on additional infrastructure components.</p>"},{"location":"examples/#supervision-example","title":"Supervision Example","text":"<p>The Supervision Example demonstrates how to build hierarchical actor supervision systems with real-time visualization. It shows:</p> <ul> <li>Building hierarchical actor systems with arbitrary depth</li> <li>Implementing different supervision strategies (restart, stop, resume)</li> <li>Visualizing actor hierarchies in real-time with an interactive web UI</li> <li>Tracking actor failures and monitoring supervision behavior</li> <li>Creating fault-tolerant systems using the actor model</li> </ul> <p>This example provides insights into how supervision trees can be used to build resilient, self-healing systems with clear failure boundaries.</p>"},{"location":"examples/#monitoring","title":"Monitoring","text":"<p>The Monitoring example demonstrates how to monitor and analyze your actor system's performance. It shows:</p> <ul> <li>Setting up a complete monitoring stack with Prometheus and Grafana</li> <li>Collecting and exporting metrics from your actor system</li> <li>Visualizing actor performance metrics in real-time</li> <li>Tracking message processing times and throughput</li> <li>Monitoring cluster health and resource usage</li> </ul> <p>This example provides insights into how Spring Boot Starter Actor can be used to observe and optimize your application's performance without complex configuration.</p>"},{"location":"examples/#getting-started","title":"Getting Started","text":"<p>To run these examples:</p> <ol> <li>Clone the repository</li> <li>Navigate to the example directory you want to run</li> <li>Follow the instructions in the corresponding documentation file</li> </ol>"},{"location":"examples/#additional-resources","title":"Additional Resources","text":"<ul> <li>Spring Boot Starter Actor Documentation</li> <li>API Reference</li> <li>GitHub Repository</li> </ul>"},{"location":"examples/chat/","title":"Chat Example","text":"<p> This guide demonstrates how to build a real-time chat application using Spring Boot Starter Actor without introducing third-party middleware.</p>"},{"location":"examples/chat/#overview","title":"Overview","text":"<p>The chat example shows how to:</p> <ul> <li>Build a real-time chat application using actors</li> <li>Implement WebSocket communication for real-time messaging</li> <li>Create a scalable, clustered chat system</li> <li>Eliminate the need for external message brokers or middleware</li> </ul> <p>This example demonstrates how Spring Boot Starter Actor can be used to build real-world applications efficiently without relying on additional infrastructure components.</p>"},{"location":"examples/chat/#source-code","title":"Source Code","text":"<p>You can find the complete source code for this example on GitHub: https://github.com/seonWKim/spring-boot-starter-actor/tree/main/example/chat</p>"},{"location":"examples/chat/#key-components","title":"Key Components","text":""},{"location":"examples/chat/#chatroomactor","title":"ChatRoomActor","text":"<p><code>ChatRoomActor</code> is a sharded actor that manages a chat room. Each chat room is a separate entity identified by a room ID. The actor maintains a list of connected users and broadcasts messages to all users in the room:</p> <pre><code>@Component\npublic class ChatRoomActor implements ShardedActor&lt;ChatRoomActor.Command&gt; {\n\n    public static final EntityTypeKey&lt;Command&gt; TYPE_KEY =\n            EntityTypeKey.create(Command.class, \"ChatRoomActor\");\n\n    /** Base interface for all commands that can be sent to the chat room actor. */\n    public interface Command extends JsonSerializable {}\n\n    /** Command to join a chat room. */\n    public static class JoinRoom implements Command {\n        public final String userId;\n        public final ActorRef&lt;UserActor.Command&gt; userRef;\n\n        @JsonCreator\n        public JoinRoom(\n                @JsonProperty(\"userId\") String userId,\n                @JsonProperty(\"userRef\") ActorRef&lt;UserActor.Command&gt; userRef) {\n            this.userId = userId;\n            this.userRef = userRef;\n        }\n    }\n\n    /** Command to leave a chat room. */\n    public static class LeaveRoom implements Command {\n        public final String userId;\n\n        @JsonCreator\n        public LeaveRoom(@JsonProperty(\"userId\") String userId) {\n            this.userId = userId;\n        }\n    }\n\n    /** Command to send a message to the chat room. */\n    public static class SendMessage implements Command {\n        public final String userId;\n        public final String message;\n\n        @JsonCreator\n        public SendMessage(\n                @JsonProperty(\"userId\") String userId, @JsonProperty(\"message\") String message) {\n            this.userId = userId;\n            this.message = message;\n        }\n    }\n\n    @Override\n    public EntityTypeKey&lt;Command&gt; typeKey() {\n        return TYPE_KEY;\n    }\n\n    @Override\n    public Behavior&lt;Command&gt; create(EntityContext&lt;Command&gt; ctx) {\n        return Behaviors.setup(\n                context -&gt; {\n                    final String roomId = ctx.getEntityId();\n                    return chatRoom(roomId, new HashMap&lt;&gt;());\n                });\n    }\n\n    /**\n     * Creates the behavior for a chat room with the given room ID and connected users.\n     *\n     * @param roomId The ID of the chat room\n     * @param connectedUsers Map of user IDs to their actor references\n     *\n     * @return The behavior for the chat room\n     */\n    private Behavior&lt;Command&gt; chatRoom(\n            String roomId,\n            Map&lt;String, ActorRef&lt;UserActor.Command&gt;&gt; connectedUsers\n    ) {\n        return Behaviors.receive(Command.class)\n                        .onMessage(\n                                JoinRoom.class,\n                                msg -&gt; {\n                                    // Add the user to the connected users\n                                    connectedUsers.put(msg.userId, msg.userRef);\n\n                                    // Notify all users that a new user has joined\n                                    UserActor.JoinRoomEvent joinRoomEvent = new UserActor.JoinRoomEvent(\n                                            msg.userId);\n                                    broadcastCommand(connectedUsers, joinRoomEvent);\n\n                                    return chatRoom(roomId, connectedUsers);\n                                })\n                        .onMessage(\n                                LeaveRoom.class,\n                                msg -&gt; {\n                                    // Remove the user from connected users\n                                    ActorRef&lt;UserActor.Command&gt; userRef = connectedUsers.remove(msg.userId);\n\n                                    if (userRef != null) {\n                                        // Notify the user that they left the room\n                                        UserActor.LeaveRoomEvent leaveRoomEvent = new UserActor.LeaveRoomEvent(\n                                                msg.userId);\n                                        userRef.tell(leaveRoomEvent);\n\n                                        // Notify all remaining users that a user has left\n                                        broadcastCommand(connectedUsers, leaveRoomEvent);\n                                    }\n\n                                    return chatRoom(roomId, connectedUsers);\n                                })\n                        .onMessage(\n                                SendMessage.class,\n                                msg -&gt; {\n                                    // Create a message received command\n                                    UserActor.SendMessageEvent receiveMessageCmd =\n                                            new UserActor.SendMessageEvent(msg.userId, msg.message);\n\n                                    // Broadcast the message to all connected users\n                                    broadcastCommand(connectedUsers, receiveMessageCmd);\n\n                                    return Behaviors.same();\n                                })\n                        .build();\n    }\n\n    /**\n     * Broadcasts a command to all connected users.\n     *\n     * @param connectedUsers Map of user IDs to their actor references\n     * @param command The command to broadcast\n     */\n    private void broadcastCommand(Map&lt;String, ActorRef&lt;UserActor.Command&gt;&gt; connectedUsers,\n                                  UserActor.Command command) {\n        connectedUsers.values().forEach(userRef -&gt; userRef.tell(command));\n    }\n\n    @Override\n    public ShardingMessageExtractor&lt;ShardEnvelope&lt;Command&gt;, Command&gt; extractor() {\n        return new DefaultShardingMessageExtractor&lt;&gt;(3);\n    }\n}\n</code></pre>"},{"location":"examples/chat/#useractor","title":"UserActor","text":"<p><code>UserActor</code> represents a connected user and handles sending messages to the user's WebSocket connection. It's implemented as a SpringActor that interacts with ChatRoomActor:</p> <pre><code>@Component\npublic class UserActor implements SpringActor&lt;UserActor, UserActor.Command&gt; {\n\n    public interface Command extends JsonSerializable {}\n\n    public static class Connect implements Command {\n    }\n\n    public static class JoinRoom implements Command {\n        private final String roomId;\n\n        public JoinRoom(String roomId) {this.roomId = roomId;}\n    }\n\n    public static class LeaveRoom implements Command {\n        public LeaveRoom() {}\n    }\n\n    public static class SendMessage implements Command {\n        private final String message;\n\n        public SendMessage(String message) {this.message = message;}\n    }\n\n    public static class JoinRoomEvent implements Command {\n        private final String userId;\n\n        public JoinRoomEvent(String userId) {this.userId = userId;}\n    }\n\n    public static class LeaveRoomEvent implements Command {\n        private final String userId;\n\n        public LeaveRoomEvent(String userId) {this.userId = userId;}\n    }\n\n    public static class SendMessageEvent implements Command {\n        private final String userId;\n        private final String message;\n\n        public SendMessageEvent(String userId, String message) {\n            this.userId = userId;\n            this.message = message;\n        }\n    }\n\n    public static class UserActorContext implements SpringActorContext {\n        private final SpringActorSystem actorSystem;\n        private final ObjectMapper objectMapper;\n        private final WebSocketSession session;\n\n        private final String userId;\n\n        public UserActorContext(SpringActorSystem actorSystem, ObjectMapper objectMapper, String userId,\n                              WebSocketSession session) {\n            this.actorSystem = actorSystem;\n            this.objectMapper = objectMapper;\n            this.userId = userId;\n            this.session = session;\n        }\n\n        @Override\n        public String actorId() {\n            return userId;\n        }\n    }\n\n    @Override\n    public Behavior&lt;Command&gt; create(SpringActorContext actorContext) {\n        if (!(actorContext instanceof UserActorContext userActorContext)) {\n            throw new IllegalStateException(\"Must be UserActorContext\");\n        }\n\n        return Behaviors.setup(\n                context -&gt; new UserActorBehavior(\n                        context,\n                        userActorContext.actorSystem,\n                        userActorContext.objectMapper,\n                        userActorContext.userId,\n                        userActorContext.session\n                ).create()\n        );\n    }\n\n    public static class UserActorBehavior {\n        private final ActorContext&lt;UserActor.Command&gt; context;\n        private final SpringActorSystem actorSystem;\n        private final ObjectMapper objectMapper;\n\n        private final String userId;\n        private final WebSocketSession session;\n\n        @Nullable\n        private String currentRoomId;\n\n        public UserActorBehavior(ActorContext&lt;Command&gt; context, SpringActorSystem actorSystem,\n                               ObjectMapper objectMapper, String userId, WebSocketSession session) {\n            this.context = context;\n            this.actorSystem = actorSystem;\n            this.objectMapper = objectMapper;\n            this.userId = userId;\n            this.session = session;\n        }\n\n        public Behavior&lt;UserActor.Command&gt; create() {\n            return Behaviors.receive(Command.class)\n                            .onMessage(Connect.class, this::onConnect)\n                            .onMessage(JoinRoom.class, this::onJoinRoom)\n                            .onMessage(LeaveRoom.class, this::onLeaveRoom)\n                            .onMessage(SendMessage.class, this::onSendMessage)\n                            .onMessage(JoinRoomEvent.class, this::onJoinRoomEvent)\n                            .onMessage(LeaveRoomEvent.class, this::onLeaveRoomEvent)\n                            .onMessage(SendMessageEvent.class, this::onSendMessageEvent)\n                            .build();\n        }\n\n        private Behavior&lt;Command&gt; onConnect(Connect connect) {\n            sendEvent(\n                    \"connected\",\n                    builder -&gt; {\n                        builder.put(\"userId\", userId);\n                    });\n\n            return Behaviors.same();\n        }\n\n        private Behavior&lt;Command&gt; onJoinRoom(JoinRoom command) {\n            currentRoomId = command.roomId;\n            final var roomActor = getRoomActor();\n            sendEvent(\n                    \"joined\",\n                    builder -&gt; {\n                        builder.put(\"roomId\", currentRoomId);\n                    });\n\n            roomActor.tell(new ChatRoomActor.JoinRoom(userId, context.getSelf()));\n            return Behaviors.same();\n        }\n\n        private Behavior&lt;Command&gt; onLeaveRoom(LeaveRoom command) {\n            if (currentRoomId == null) {\n                context.getLog().info(\"{} user has not joined any room.\", userId);\n                return Behaviors.same();\n            }\n\n            sendEvent(\n                    \"left\",\n                    builder -&gt; {\n                        builder.put(\"roomId\", currentRoomId);\n                    });\n\n            final var roomActor = getRoomActor();\n            roomActor.tell(new ChatRoomActor.LeaveRoom(userId));\n\n            return Behaviors.same();\n        }\n\n        private Behavior&lt;Command&gt; onSendMessage(SendMessage command) {\n            if (currentRoomId == null) {\n                context.getLog().info(\"{} user has not joined any room.\", userId);\n                return Behaviors.same();\n            }\n\n            final var roomActor = getRoomActor();\n            roomActor.tell(new ChatRoomActor.SendMessage(userId, command.message));\n\n            return Behaviors.same();\n        }\n\n        private Behavior&lt;Command&gt; onJoinRoomEvent(JoinRoomEvent event) {\n            sendEvent(\n                    \"user_joined\",\n                    builder -&gt; {\n                        builder.put(\"userId\", event.userId);\n                        builder.put(\"roomId\", currentRoomId);\n                    });\n            return Behaviors.same();\n        }\n\n        private Behavior&lt;Command&gt; onLeaveRoomEvent(LeaveRoomEvent event) {\n            sendEvent(\n                    \"user_left\",\n                    builder -&gt; {\n                        builder.put(\"userId\", event.userId);\n                        builder.put(\"roomId\", currentRoomId);\n                    });\n            return Behaviors.same();\n        }\n\n        private Behavior&lt;Command&gt; onSendMessageEvent(SendMessageEvent event) {\n            sendEvent(\n                    \"message\",\n                    builder -&gt; {\n                        builder.put(\"userId\", event.userId);\n                        builder.put(\"message\", event.message);\n                        builder.put(\"roomId\", currentRoomId);\n                    });\n            return Behaviors.same();\n        }\n\n        private SpringShardedActorRef&lt;ChatRoomActor.Command&gt; getRoomActor() {\n            return actorSystem.sharded(ChatRoomActor.class).withId(currentRoomId).get(); \n        }\n\n        private void sendEvent(String type, EventBuilder builder) {\n            try {\n                ObjectNode eventNode = objectMapper.createObjectNode();\n                eventNode.put(\"type\", type);\n                builder.build(eventNode);\n\n                if (session.isOpen()) {\n                    session.sendMessage(new TextMessage(objectMapper.writeValueAsString(eventNode)));\n                }\n            } catch (IOException e) {\n                context.getLog().error(\"Failed to send message to WebSocket\", e);\n            }\n        }\n\n        @FunctionalInterface\n        private interface EventBuilder {\n            void build(ObjectNode node);\n        }\n    }\n}\n</code></pre>"},{"location":"examples/chat/#chatwebsockethandler","title":"ChatWebSocketHandler","text":"<p><code>ChatWebSocketHandler</code> handles WebSocket connections and messages:</p> <pre><code>@Component\npublic class ChatWebSocketHandler extends TextWebSocketHandler {\n\n    private final ObjectMapper objectMapper;\n    private final SpringActorSystem actorSystem;\n    private final ConcurrentMap&lt;String, SpringActorRef&lt;UserActor.Command&gt;&gt; userActors =\n            new ConcurrentHashMap&lt;&gt;();\n\n    public ChatWebSocketHandler(\n            ObjectMapper objectMapper, SpringActorSystem actorSystem) {\n        this.objectMapper = objectMapper;\n        this.actorSystem = actorSystem;\n    }\n\n    @Override\n    public void afterConnectionEstablished(WebSocketSession session) {\n        String userId = UUID.randomUUID().toString();\n        session.getAttributes().put(\"userId\", userId);\n        UserActor.UserActorContext userActorContext =\n                new UserActor.UserActorContext(actorSystem, objectMapper, userId, session);\n\n        final SpringActorSpawnContext&lt;UserActor, UserActor.Command&gt; spawnContext =\n                new SpringActorSpawnContext.Builder&lt;&gt;(UserActor.class)\n                        .actorContext(userActorContext)\n                        .build();\n\n        actorSystem.actor(spawnContext)\n                   .thenAccept(userActor -&gt; {\n                       userActors.put(userId, userActor);\n                       userActor.tell(new Connect());\n                   });\n    }\n\n    @Override\n    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {\n        String userId = (String) session.getAttributes().get(\"userId\");\n        JsonNode payload = objectMapper.readTree(message.getPayload());\n        String type = payload.get(\"type\").asText();\n\n        switch (type) {\n            case \"join\":\n                handleJoinRoom(userId, payload);\n                break;\n            case \"leave\":\n                handleLeaveRoom(userId);\n                break;\n            case \"message\":\n                handleChatMessage(userId, payload);\n                break;\n            default:\n                sendErrorMessage(session, \"Unknown message type: \" + type);\n        }\n    }\n\n    @Override\n    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {\n        final String userId = (String) session.getAttributes().get(\"userId\");\n        final var userActor = getUserActor(userId);\n        if (userId != null &amp;&amp; userActor != null) {\n            userActor.stop();\n            userActors.remove(userId);\n        }\n    }\n\n    private void handleJoinRoom(String userId, JsonNode payload) {\n        String roomId = payload.get(\"roomId\").asText();\n        final var userActor = getUserActor(userId);\n        if (roomId != null &amp;&amp; userActor != null) {\n            userActor.tell(new JoinRoom(roomId));\n        }\n    }\n\n    private void handleLeaveRoom(String userId) {\n        final var userActor = getUserActor(userId);\n        if (userActor != null) {\n            userActor.tell(new LeaveRoom());\n        }\n    }\n\n    private void handleChatMessage(String userId, JsonNode payload) {\n        final var userActor = getUserActor(userId);\n        String messageText = payload.get(\"message\").asText();\n        if (userActor != null &amp;&amp; messageText != null) {\n            userActor.tell(new SendMessage(messageText));\n        }\n    }\n\n    private SpringActorRef&lt;UserActor.Command&gt; getUserActor(String userId) {\n        if (userId == null) {\n            return null;\n        }\n\n        return userActors.get(userId);\n    }\n\n    private void sendErrorMessage(WebSocketSession session, String errorMessage) {\n        try {\n            if (session.isOpen()) {\n                ObjectNode response = objectMapper.createObjectNode();\n                response.put(\"type\", \"error\");\n                response.put(\"message\", errorMessage);\n                session.sendMessage(new TextMessage(objectMapper.writeValueAsString(response)));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>"},{"location":"examples/chat/#running-the-application","title":"Running the Application","text":""},{"location":"examples/chat/#local-cluster-setup","title":"Local Cluster Setup","text":"<p>You can run multiple instances of the application locally using the provided <code>cluster-start.sh</code> script:</p> <pre><code>./cluster-start.sh chat io.github.seonwkim.example.SpringPekkoApplication 8080 2551 3\n</code></pre> <p>This will start 3 instances of the application with the following configuration: - Instance 1: HTTP port 8080, Pekko port 2551 - Instance 2: HTTP port 8081, Pekko port 2552 - Instance 3: HTTP port 8082, Pekko port 2553</p> <p>To stop the cluster: <pre><code>./cluster-stop.sh\n</code></pre></p>"},{"location":"examples/chat/#docker-deployment","title":"Docker Deployment","text":"<p>You can also deploy the chat application as a clusterized app using Docker:</p> <pre><code># Navigate to the chat example directory\ncd example/chat\n\n# Run the init-local-docker.sh script to build and deploy the application\nsh init-local-docker.sh\n</code></pre> <p>This script will:</p> <ol> <li>Build the chat application JAR file</li> <li>Build a Docker image for the application</li> <li>Deploy a 3-node Pekko cluster using Docker Compose</li> <li>Each node will be accessible at:</li> <li>Node 1: http://localhost:8080</li> <li>Node 2: http://localhost:8081</li> <li>Node 3: http://localhost:8082</li> </ol>"},{"location":"examples/chat/#viewing-logs","title":"Viewing Logs","text":"<p>To view logs for a specific node: <pre><code>docker-compose logs -f chat-app-0\n</code></pre></p>"},{"location":"examples/chat/#stopping-the-deployment","title":"Stopping the Deployment","text":"<p>To stop the Docker deployment: <pre><code>docker-compose down\n</code></pre></p> <p>The Docker deployment uses the same application code but configures it to run in a containerized environment, making it easier to deploy and scale in production scenarios.</p>"},{"location":"examples/chat/#architecture-benefits","title":"Architecture Benefits","text":"<p>This architecture eliminates the need for third-party middleware by leveraging:</p> <ul> <li>Built-in message routing between actors</li> <li>Natural state management within actors</li> <li>Scalability through sharded actors</li> <li>Real-time communication via WebSockets</li> <li>Fault tolerance provided by the actor system</li> </ul>"},{"location":"examples/chat/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>The actor model provides an effective way to handle real-time communication</li> <li>WebSockets combined with actors create an efficient messaging system</li> </ul>"},{"location":"examples/cluster/","title":"Cluster Example","text":"<p>This guide demonstrates how to use Spring Boot Starter Actor in a clustered environment, focusing on how entities can be easily used with the library.</p>"},{"location":"examples/cluster/#overview","title":"Overview","text":"<p>The cluster example shows how to:</p> <ul> <li>Create and use sharded actors across a cluster</li> <li>Distribute actor instances across multiple nodes</li> <li>Send messages to specific entity instances</li> <li>Handle entity state in a distributed environment</li> </ul> <p>This example demonstrates the power of the actor model for building scalable, distributed applications with Spring Boot.</p>"},{"location":"examples/cluster/#source-code","title":"Source Code","text":"<p>You can find the complete source code for this example on GitHub: https://github.com/seonWKim/spring-boot-starter-actor/tree/main/example/cluster</p>"},{"location":"examples/cluster/#key-components","title":"Key Components","text":""},{"location":"examples/cluster/#helloactor","title":"HelloActor","text":"<p><code>HelloActor</code> is a sharded actor that responds to messages in a clustered environment. Each entity is a separate instance identified by an entity ID. The actor demonstrates:</p> <ul> <li>How to implement the <code>ShardedActor</code> interface</li> <li>How to define serializable message types for cluster communication</li> <li>How to create entity behaviors</li> <li>How to handle messages in a clustered environment</li> </ul> <pre><code>@Component\npublic class HelloActor implements ShardedActor&lt;HelloActor.Command&gt; {\n    public static final EntityTypeKey&lt;Command&gt; TYPE_KEY =\n            EntityTypeKey.create(Command.class, \"HelloActor\");\n\n    // Command interface and message types\n    public interface Command extends JsonSerializable {}\n\n    public static class SayHello implements Command {\n        public final ActorRef&lt;String&gt; replyTo;\n        public final String message;\n\n        @JsonCreator\n        public SayHello(\n                @JsonProperty(\"replyTo\") ActorRef&lt;String&gt; replyTo,\n                @JsonProperty(\"message\") String message) {\n            this.replyTo = replyTo;\n            this.message = message;\n        }\n    }\n\n    @Override\n    public EntityTypeKey&lt;Command&gt; typeKey() {\n        return TYPE_KEY;\n    }\n\n    @Override\n    public Behavior&lt;Command&gt; create(EntityContext&lt;Command&gt; ctx) {\n        return Behaviors.setup(\n                context -&gt;\n                        Behaviors.receive(Command.class)\n                                .onMessage(\n                                        SayHello.class,\n                                        msg -&gt; {\n                                            // Get information about the current node and entity\n                                            final String nodeAddress = context.getSystem().address().toString();\n                                            final String entityId = ctx.getEntityId();\n\n                                            // Create a response message with node and entity information\n                                            final String message =\n                                                    \"Received from entity [\" + entityId + \"] on node [\" + nodeAddress + \"]\";\n\n                                            // Send the response back to the caller\n                                            msg.replyTo.tell(message);\n\n                                            return Behaviors.same();\n                                        })\n                                .build());\n    }\n\n    @Override\n    public ShardingMessageExtractor&lt;ShardEnvelope&lt;Command&gt;, Command&gt; extractor() {\n        return new DefaultShardingMessageExtractor&lt;&gt;(3);\n    }\n}\n</code></pre>"},{"location":"examples/cluster/#helloservice","title":"HelloService","text":"<p><code>HelloService</code> acts as an intermediary between the REST API and the actor system:</p> <ul> <li>It gets references to actor entities using the sharded method</li> <li>It provides methods to send messages to specific entities and return the responses</li> <li>It converts actor responses to reactive Mono objects for use with Spring WebFlux</li> </ul> <pre><code>@Service\npublic class HelloService {\n    private final SpringActorSystem springActorSystem;\n\n    public HelloService(SpringActorSystem springActorSystem) {\n        this.springActorSystem = springActorSystem;\n    }\n\n    public Mono&lt;String&gt; hello(String message, String entityId) {\n        // Get a reference to the actor entity\n        SpringShardedActorRef&lt;HelloActor.Command&gt; actorRef =\n                springActorSystem.sharded(HelloActor.class).withId(entityId).get();\n\n        // Send the message to the actor and get the response\n        CompletionStage&lt;String&gt; response =\n                actorRef.ask(replyTo -&gt; new HelloActor.SayHello(replyTo, message), Duration.ofSeconds(3));\n\n        // Convert the CompletionStage to a Mono for reactive programming\n        return Mono.fromCompletionStage(response);\n    }\n}\n</code></pre>"},{"location":"examples/cluster/#hellocontroller","title":"HelloController","text":"<p><code>HelloController</code> exposes the actor functionality via a REST API:</p> <ul> <li>It injects the HelloService</li> <li>It defines REST endpoints that call the service methods with entity IDs</li> <li>It returns the actor responses as HTTP responses</li> </ul> <pre><code>@RestController\npublic class HelloController {\n    private final HelloService helloService;\n\n    public HelloController(HelloService helloService) {\n        this.helloService = helloService;\n    }\n\n    @GetMapping(\"/hello\")\n    public Mono&lt;String&gt; hello(@RequestParam String message, @RequestParam String entityId) {\n        return helloService.hello(message, entityId);\n    }\n}\n</code></pre>"},{"location":"examples/cluster/#configuration","title":"Configuration","text":"<p>The cluster example requires additional configuration to set up the actor cluster:</p> <pre><code>spring:\n  application:\n    name: spring-pekko\n  actor:\n    pekko:\n      name: spring-pekko-example\n      actor:\n        provider: cluster\n        allow-java-serialization: off\n        warn-about-java-serializer-usage: on\n      remote:\n        artery:\n          canonical:\n            hostname: 127.0.0.1\n            port: 2551\n      cluster:\n        name: spring-pekko-example\n        seed-nodes:\n          - pekko://spring-pekko-example@127.0.0.1:2551\n          - pekko://spring-pekko-example@127.0.0.1:2552\n          - pekko://spring-pekko-example@127.0.0.1:2553\n        downing-provider-class: org.apache.pekko.cluster.sbr.SplitBrainResolverProvider\n\nserver:\n  port: 8080\n</code></pre>"},{"location":"examples/cluster/#running-the-example","title":"Running the Example","text":"<p>To run the cluster example:</p> <ol> <li>Start multiple instances of the application with different ports</li> <li>Access the <code>/hello</code> endpoint with a message and entity ID</li> <li>Observe how the same entity ID always routes to the same node</li> <li>Try different entity IDs to see how they are distributed across the cluster</li> </ol>"},{"location":"examples/cluster/#entity-benefits","title":"Entity Benefits","text":"<p>Entities in Spring Boot Starter Actor provide:</p> <ul> <li>Automatic distribution across the cluster</li> <li>Location transparency for messaging</li> <li>Scalability with cluster expansion</li> <li>Fault tolerance with automatic recreation</li> <li>Simplified state management</li> </ul>"},{"location":"examples/monitoring/","title":"Monitoring","text":"<p>This guide demonstrates how to set up and use the built-in monitoring capabilities of Spring Boot Starter Actor to observe and analyze your actor system's performance.</p>"},{"location":"examples/monitoring/#overview","title":"Overview","text":"<p>The monitoring example shows how to:</p> <ul> <li>Set up a complete monitoring stack with Prometheus and Grafana</li> <li>Collect and export metrics from your actor system</li> <li>Visualize actor performance metrics in real-time</li> <li>Track message processing times and throughput</li> <li>Monitor cluster health and resource usage</li> </ul> <p>Spring Boot Starter Actor provides comprehensive monitoring capabilities without requiring complex configuration or third-party services.</p>"},{"location":"examples/monitoring/#key-components","title":"Key Components","text":""},{"location":"examples/monitoring/#metrics-module","title":"Metrics Module","text":"<p>The Metrics module provides instrumentation for Pekko actors to collect performance metrics. It uses a Java agent to intercept method calls and capture timing information.</p> <pre><code>// Include the Java agent when starting your application\njava -javaagent:metrics-{version}-agent.jar -jar your-application.jar\n</code></pre>"},{"location":"examples/monitoring/#actorinstrumentationeventlistener","title":"ActorInstrumentationEventListener","text":"<p>The <code>ActorInstrumentationEventListener</code> allows you to capture metrics about actor message processing:</p> <pre><code>import io.github.seonwkim.metrics.ActorInstrumentationEventListener;\nimport io.github.seonwkim.metrics.ActorInstrumentationEventListener.InvokeAdviceEventListener;\n\n// Register a listener for actor messages\nActorInstrumentationEventListener.register(new InvokeAdviceEventListener() {\n    @Override\n    public void onEnter(Envelope envelope) {\n        // Called when a message is about to be processed\n    }\n\n    @Override\n    public void onExit(Envelope envelope, long startTime, Throwable throwable) {\n        // Called when message processing is complete\n        // Calculate duration: System.nanoTime() - startTime\n    }\n});\n</code></pre>"},{"location":"examples/monitoring/#metrics-exporter","title":"Metrics Exporter","text":"<p>The <code>ActorClusterMetricsExporter</code> shows how to export metrics to Prometheus via Micrometer:</p> <pre><code>@Component\npublic class ActorClusterMetricsExporter {\n    private final MeterRegistry registry;\n    private final ConcurrentHashMap&lt;String, Timer&gt; invokeTimers = new ConcurrentHashMap&lt;&gt;();\n    private final ConcurrentHashMap&lt;String, Counter&gt; invokeCounters = new ConcurrentHashMap&lt;&gt;();\n\n    // Define which message types to track\n    private final Set&lt;Class&lt;?&gt;&gt; targetClasses = Set.of(\n        ChatRoomActor.JoinRoom.class,\n        ChatRoomActor.LeaveRoom.class,\n        ChatRoomActor.SendMessage.class\n    );\n\n    public ActorClusterMetricsExporter(MeterRegistry registry) {\n        this.registry = registry;\n    }\n\n    @PostConstruct\n    public void registerMetrics() {\n        ActorInstrumentationEventListener.register(new InvokeAdviceEventListener() {\n            @Override\n            public void onEnter(Envelope envelope) {}\n\n            @Override\n            public void onExit(Envelope envelope, long startTime, Throwable throwable) {\n                if (!targetClasses.contains(envelope.message().getClass())) {\n                    return;\n                }\n\n                String messageType = envelope.message().getClass().getSimpleName();\n\n                // Record timing metrics\n                Timer timer = invokeTimers.computeIfAbsent(messageType, mt -&gt;\n                    Timer.builder(\"pekko.actorcell.invoke.timer\")\n                         .description(\"Time spent processing messages\")\n                         .tags(\"messageType\", mt)\n                         .register(registry)\n                );\n\n                // Record count metrics\n                Counter counter = invokeCounters.computeIfAbsent(messageType, mt -&gt;\n                    Counter.builder(\"pekko.actorcell.invoke.count\")\n                           .description(\"Count of messages processed\")\n                           .tags(\"messageType\", mt)\n                           .register(registry)\n                );\n\n                long duration = System.nanoTime() - startTime;\n                timer.record(duration, TimeUnit.NANOSECONDS);\n                counter.increment();\n            }\n        });\n    }\n}\n</code></pre>"},{"location":"examples/monitoring/#setting-up-the-monitoring-stack","title":"Setting Up the Monitoring Stack","text":"<p>Spring Boot Starter Actor includes a ready-to-use monitoring stack with Prometheus and Grafana, managed via Docker Compose.</p>"},{"location":"examples/monitoring/#1-start-the-monitoring-stack","title":"1. Start the Monitoring Stack","text":"<p>Navigate to the monitoring directory and start the stack:</p> <pre><code>cd scripts/monitoring\ndocker-compose up -d\n</code></pre> <p>This will start: - Prometheus at http://localhost:9090 - Grafana at http://localhost:3000</p>"},{"location":"examples/monitoring/#2-configure-your-application","title":"2. Configure Your Application","text":"<p>Ensure your application exposes metrics via Spring Boot Actuator:</p> <pre><code># application.yaml\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,info,prometheus\n  metrics:\n    export:\n      prometheus:\n        enabled: true\n</code></pre>"},{"location":"examples/monitoring/#3-access-the-dashboards","title":"3. Access the Dashboards","text":"<p>Open Grafana at http://localhost:3000 (default credentials: admin/admin) to view the pre-configured dashboards.</p>"},{"location":"examples/monitoring/#4-shutdown-when-done","title":"4. Shutdown When Done","text":"<pre><code>cd scripts/monitoring\ndocker-compose down -v\n</code></pre>"},{"location":"examples/monitoring/#summary","title":"Summary","text":"<ul> <li>Collect performance data with the metrics module</li> <li>Visualize with Prometheus and Grafana</li> </ul>"},{"location":"examples/simple/","title":"Simple Example","text":"<p>This guide demonstrates the basic usage of Spring Boot Starter Actor in a simple, non-clustered environment.</p>"},{"location":"examples/simple/#overview","title":"Overview","text":"<p>The simple example shows how to:</p> <ul> <li>Create and register actors in a Spring Boot application</li> <li>Send messages to actors and receive responses</li> <li>Integrate actors with a REST API</li> </ul> <p>This example is a great starting point for understanding the core concepts of the actor model and how Spring Boot Starter Actor makes it easy to use actors in your Spring applications.</p>"},{"location":"examples/simple/#source-code","title":"Source Code","text":"<p>You can find the complete source code for this example on GitHub: https://github.com/seonWKim/spring-boot-starter-actor/tree/main/example/simple</p>"},{"location":"examples/simple/#key-components","title":"Key Components","text":""},{"location":"examples/simple/#helloactor","title":"HelloActor","text":"<p><code>HelloActor</code> is a simple actor that responds to \"hello\" messages. It demonstrates:</p> <ul> <li>How to implement the <code>SpringActor</code> interface</li> <li>How to define message types (commands)</li> <li>How to create actor behaviors</li> <li>How to handle messages and send responses</li> <li>How to use lifecycle hooks: PreStart (called in <code>create()</code>), PreRestart and PostStop (using <code>onSignal</code>)</li> </ul> <pre><code>@Component\npublic class HelloActor implements SpringActor&lt;HelloActor, HelloActor.Command&gt; {\n    // Command interface and message types\n    public interface Command {}\n\n    public static class SayHello implements Command {\n        public final ActorRef&lt;String&gt; replyTo;\n\n        public SayHello(ActorRef&lt;String&gt; replyTo) {\n            this.replyTo = replyTo;\n        }\n    }\n\n    @Override\n    public Behavior&lt;Command&gt; create(SpringActorContext actorContext) {\n        return Behaviors.setup(ctx -&gt; new HelloActorBehavior(ctx, actorContext).create());\n    }\n\n    // Actor behavior implementation\n    private static class HelloActorBehavior {\n        // Implementation details...\n\n        public Behavior&lt;Command&gt; create() {\n            // Call prestart hook for initialization logic\n            onPrestart();\n\n            // Create the base behavior\n            Behavior&lt;Command&gt; behavior = Behaviors.receive(Command.class)\n                    .onMessage(SayHello.class, this::onSayHello)\n                    .onMessage(TriggerFailure.class, this::onTriggerFailure)\n                    // Signal handlers for lifecycle events\n                    .onSignal(PreRestart.class, this::onPreRestart)\n                    .onSignal(PostStop.class, this::onPostStop)\n                    .build();\n\n            // Wrap with supervision strategy to restart on failure\n            return Behaviors.supervise(behavior)\n                    .onFailure(SupervisorStrategy.restart()\n                            .withLimit(10, Duration.ofMinutes(1)));\n        }\n\n        private Behavior&lt;Command&gt; onSayHello(SayHello msg) {\n            // Send response\n            msg.replyTo.tell(\"Hello from actor \" + actorContext.actorId());\n            return Behaviors.same();\n        }\n\n        private Behavior&lt;Command&gt; onTriggerFailure(TriggerFailure msg) {\n            // Throw exception to trigger restart (requires supervision strategy)\n            ctx.getLog().warn(\"Triggering failure for actor {}\", actorContext.actorId());\n            msg.replyTo.tell(\"Triggering failure - actor will restart\");\n            throw new RuntimeException(\"Intentional failure to demonstrate PreRestart\");\n        }\n\n        private void onPrestart() {\n            // Initialize resources when actor starts\n            ctx.getLog().info(\"PreStart hook for id={}\", actorContext.actorId());\n        }\n\n        private Behavior&lt;Command&gt; onPreRestart(PreRestart signal) {\n            // Cleanup before restart (e.g., close connections, release resources)\n            ctx.getLog().warn(\"Actor {} is being restarted\", actorContext.actorId());\n            return Behaviors.same();\n        }\n\n        private Behavior&lt;Command&gt; onPostStop(PostStop signal) {\n            // Final cleanup when actor stops\n            ctx.getLog().info(\"Actor {} is stopping\", actorContext.actorId());\n            return Behaviors.same();\n        }\n    }\n}\n</code></pre>"},{"location":"examples/simple/#helloservice","title":"HelloService","text":"<p><code>HelloService</code> acts as an intermediary between the REST API and the actor system:</p> <ul> <li>It spawns a HelloActor instance</li> <li>It provides methods to send messages to the actor and return the responses</li> <li>It converts actor responses to reactive Mono objects for use with Spring WebFlux</li> </ul> <pre><code>@Service\npublic class HelloService {\n    private final SpringActorRef&lt;Command&gt; helloActor;\n\n    public HelloService(SpringActorSystem springActorSystem) {\n        // Spawn a single actor using the simplified fluent API\n        this.helloActor = springActorSystem\n                .actor(HelloActor.class)\n                .withId(\"default\")\n                .withTimeout(Duration.ofSeconds(3))\n                .startAndWait();\n    }\n\n    public Mono&lt;String&gt; hello() {\n        // Send a SayHello message to the actor and convert the response to a Mono\n        return Mono.fromCompletionStage(\n                helloActor.ask(HelloActor.SayHello::new, Duration.ofSeconds(3)));\n    }\n}\n</code></pre>"},{"location":"examples/simple/#hellocontroller","title":"HelloController","text":"<p><code>HelloController</code> exposes the actor functionality via a REST API:</p> <ul> <li>It injects the HelloService</li> <li>It defines REST endpoints that call the service methods</li> <li>It returns the actor responses as HTTP responses</li> </ul> <pre><code>@RestController\npublic class HelloController {\n    private final HelloService helloService;\n\n    public HelloController(HelloService helloService) {\n        this.helloService = helloService;\n    }\n\n    @GetMapping(\"/hello\")\n    public Mono&lt;String&gt; hello() {\n        return helloService.hello();\n    }\n}\n</code></pre>"},{"location":"examples/simple/#actor-lifecycle-hooks","title":"Actor Lifecycle Hooks","text":"<p>The HelloActor demonstrates how to use lifecycle hooks to handle important events during an actor's lifetime. Pekko provides different mechanisms for handling startup and shutdown events.</p>"},{"location":"examples/simple/#prestart-hook","title":"PreStart Hook","text":"<p>Unlike restart and stop events which use signals, the prestart hook is implemented by calling a method directly in your <code>create()</code> method. This is the Pekko-recommended approach for initialization logic.</p> <pre><code>public Behavior&lt;Command&gt; create() {\n    // Call prestart hook for initialization\n    onPrestart();\n\n    return Behaviors.receive(Command.class)\n        .onMessage(SayHello.class, this::onSayHello)\n        .build();\n}\n\nprivate void onPrestart() {\n    // Initialize resources when actor starts\n    ctx.getLog().info(\"Actor is starting...\");\n    // Open database connections, subscribe to events, etc.\n}\n</code></pre> <p>The prestart hook is useful for:</p> <ul> <li>Initializing resources (e.g., opening database connections, file handles)</li> <li>Subscribing to event streams or topics</li> <li>Setting up timers or scheduled tasks</li> <li>Loading initial state or configuration</li> <li>Logging actor startup</li> </ul>"},{"location":"examples/simple/#supervision-strategy","title":"Supervision Strategy","text":"<p>Important: To enable actor restarts on failure, you must wrap your behavior with a supervision strategy. By default, Pekko stops actors when they throw exceptions. A supervision strategy tells Pekko what to do when an actor fails.</p> <pre><code>// Create the base behavior\nBehavior&lt;Command&gt; behavior = Behaviors.receive(Command.class)\n    .onMessage(SayHello.class, this::onSayHello)\n    .onSignal(PreRestart.class, this::onPreRestart)\n    .build();\n\n// Wrap with supervision strategy to restart on failure\nreturn Behaviors.supervise(behavior)\n    .onFailure(SupervisorStrategy.restart()\n        .withLimit(10, Duration.ofMinutes(1)));\n</code></pre> <p>This supervision strategy: - Restarts the actor when any exception is thrown - Limits restarts to 10 times within 1 minute to prevent infinite restart loops - Enables the PreRestart signal to be triggered before restart</p> <p>Common supervision strategies: - <code>restart()</code>: Restart the actor, discarding its state - <code>resume()</code>: Resume processing, keeping the actor's state - <code>stop()</code>: Stop the actor permanently (default behavior) - <code>restartWithBackoff()</code>: Restart with exponential backoff delays</p>"},{"location":"examples/simple/#prerestart-signal","title":"PreRestart Signal","text":"<p>The <code>PreRestart</code> signal is sent to an actor before it is restarted due to a failure. Note: This requires a supervision strategy with restart behavior. This is useful for:</p> <ul> <li>Cleaning up resources that won't be automatically released (e.g., closing database connections, file handles)</li> <li>Logging the state before restart for debugging</li> <li>Notifying other parts of the system about the restart</li> <li>Releasing locks or semaphores</li> </ul> <p>Note: The actor's state will be lost during restart unless you implement state persistence.</p>"},{"location":"examples/simple/#poststop-signal","title":"PostStop Signal","text":"<p>The <code>PostStop</code> signal is sent when an actor is stopped, either gracefully or due to a failure. This is the last chance to:</p> <ul> <li>Release resources (e.g., close connections, flush buffers)</li> <li>Perform final cleanup operations</li> <li>Notify other systems that the actor is shutting down</li> <li>Log final state information</li> </ul>"},{"location":"examples/simple/#using-lifecycle-hooks","title":"Using Lifecycle Hooks","text":"<p>To implement lifecycle hooks in your actor:</p> <ol> <li>PreStart: Call a method directly in <code>create()</code> before building the behavior</li> <li>PreRestart and PostStop: Use the <code>onSignal</code> method when building your behavior</li> <li>Supervision Strategy: Wrap the behavior with <code>Behaviors.supervise()</code> to enable restarts</li> </ol> <pre><code>public Behavior&lt;Command&gt; create() {\n    // 1. PreStart: call directly\n    onPrestart();\n\n    // 2. Build behavior with signal handlers\n    Behavior&lt;Command&gt; behavior = Behaviors.receive(Command.class)\n        .onMessage(SayHello.class, this::onSayHello)\n        .onSignal(PreRestart.class, this::onPreRestart)\n        .onSignal(PostStop.class, this::onPostStop)\n        .build();\n\n    // 3. Wrap with supervision strategy to enable restart\n    return Behaviors.supervise(behavior)\n        .onFailure(SupervisorStrategy.restart()\n            .withLimit(10, Duration.ofMinutes(1)));\n}\n</code></pre> <p>The signal handlers should return <code>Behaviors.same()</code> to indicate that the actor should continue with its normal lifecycle behavior.</p>"},{"location":"examples/simple/#testing-lifecycle-hooks","title":"Testing Lifecycle Hooks","text":"<p>The simple example provides API endpoints to test each lifecycle hook:</p>"},{"location":"examples/simple/#1-test-prestart-hook","title":"1. Test PreStart Hook","text":"<p><pre><code>curl http://localhost:8080/hello\n</code></pre> Check the logs for: <code>PreStart hook for id=hello-actor</code></p>"},{"location":"examples/simple/#2-test-prerestart-signal","title":"2. Test PreRestart Signal","text":"<p><pre><code>curl http://localhost:8080/hello/restart\n</code></pre> This triggers an intentional failure. Check the logs for: - <code>Triggering failure for actor hello-actor</code> - <code>Actor hello-actor is being restarted due to failure</code> (PreRestart) - <code>PreStart hook for id=hello-actor</code> (actor restarts and PreStart is called again)</p>"},{"location":"examples/simple/#3-test-poststop-signal","title":"3. Test PostStop Signal","text":"<p><pre><code>curl http://localhost:8080/hello/stop\n</code></pre> This stops the actor using <code>SpringActorRef.stop()</code>. Check the logs for: - <code>Actor hello-actor is stopping. Performing cleanup...</code> (PostStop)</p>"},{"location":"examples/simple/#configuration","title":"Configuration","text":"<p>The simple example uses the default configuration for Spring Boot Starter Actor, which creates a local actor system. You can configure the actor system using application properties:</p> <pre><code>spring:\n  application:\n    name: spring-pekko\n  actor:\n    pekko:\n      actor:\n        provider: local\n</code></pre>"},{"location":"examples/simple/#running-the-example","title":"Running the Example","text":"<p>To run the simple example:</p> <ol> <li>Start the application using Gradle or Maven</li> <li>Access the <code>/hello</code> endpoint to send a message to the actor</li> <li>Observe the response from the actor</li> </ol>"},{"location":"examples/simple/#key-points","title":"Key Points","text":"<ul> <li>Easy integration with Spring Boot</li> <li>Simple concurrency handling</li> <li>Reactive programming support</li> </ul>"},{"location":"examples/supervision/","title":"Supervision and Restart Strategies","text":"<p>This guide demonstrates how to use supervision and restart strategies in Spring Boot Starter Actor to build fault-tolerant, self-healing applications.</p>"},{"location":"examples/supervision/#overview","title":"Overview","text":"<p>Supervision is a core concept in the actor model where parent actors monitor and respond to failures in their child actors. Spring Boot Starter Actor supports multiple supervision strategies that determine how the system handles failures.</p> <p>The supervision example provides:</p> <ul> <li>Interactive visualization of actor hierarchies and supervision behavior</li> <li>Real-time failure tracking with visual indicators</li> <li>Hands-on testing of different supervision strategies</li> <li>Multi-level hierarchies demonstrating supervision at arbitrary depth</li> </ul>"},{"location":"examples/supervision/#demo","title":"Demo","text":""},{"location":"examples/supervision/#source-code","title":"Source Code","text":"<p>Complete source code: https://github.com/seonWKim/spring-boot-starter-actor/tree/main/example/supervision</p>"},{"location":"examples/supervision/#supervision-strategies","title":"Supervision Strategies","text":"<p>Spring Boot Starter Actor provides four supervision strategies for handling child actor failures:</p>"},{"location":"examples/supervision/#1-restart-unlimited","title":"1. Restart (Unlimited)","text":"<p>Strategy:</p> <pre><code>SupervisorStrategy.restart()\n</code></pre> <p>Behavior:</p> <ul> <li>Child actor is stopped when it fails</li> <li>New instance is immediately created with fresh state</li> <li>No limit on number of restarts</li> <li>Failure continues to be tracked across restarts</li> </ul> <p>When to use:</p> <ul> <li>Transient failures that are likely to succeed on retry</li> <li>Stateless actors where losing state is acceptable</li> <li>Services that connect to external resources (databases, APIs)</li> <li>Worker actors processing independent tasks</li> </ul> <p>Example scenario: A worker actor fetching data from an external API fails due to network timeout. Restarting gives it another chance to succeed.</p>"},{"location":"examples/supervision/#2-restart-limited","title":"2. Restart (Limited)","text":"<p>Strategy:</p> <pre><code>SupervisorStrategy.restart().withLimit(maxRetries, duration)\n</code></pre> <p>Common configurations:</p> <pre><code>// Restart up to 3 times within 1 minute\nSupervisorStrategy.restart().withLimit(3,Duration.ofMinutes(1))\n\n// Restart up to 10 times within 1 hour\nSupervisorStrategy.restart().withLimit(10,Duration.ofHours(1))\n\n// Restart up to 5 times within 30 seconds\nSupervisorStrategy.restart().withLimit(5,Duration.ofSeconds(30))\n</code></pre> <p>Behavior:</p> <ul> <li>Child actor restarts after failure, but only up to the specified limit</li> <li>If limit is exceeded within the time window, the child is stopped permanently</li> <li>Counter resets after the time window expires</li> <li>Prevents infinite restart loops</li> </ul> <p>When to use:</p> <ul> <li>Preventing resource exhaustion from failing actors</li> <li>Distinguishing between transient and persistent failures</li> <li>Production systems where infinite retries could cause problems</li> <li>Critical actors where repeated failures indicate serious issues</li> </ul> <p>Example scenario: A payment processing actor should retry a few times for network issues, but stop permanently if consistently failing (indicating a configuration or system problem).</p>"},{"location":"examples/supervision/#3-stop","title":"3. Stop","text":"<p>Strategy:</p> <pre><code>SupervisorStrategy.stop()\n</code></pre> <p>Behavior:</p> <ul> <li>Child actor is stopped immediately on failure</li> <li>No restart attempted</li> <li>Parent is notified of termination</li> <li>Resources are cleaned up</li> </ul> <p>When to use:</p> <ul> <li>Fatal errors that cannot be recovered by restart</li> <li>Validation failures indicating bad configuration</li> <li>Actors that should fail fast</li> <li>Development/testing to catch errors early</li> </ul> <p>Example scenario: An actor receives invalid configuration at startup. There's no point restarting - the configuration must be fixed first.</p>"},{"location":"examples/supervision/#4-resume","title":"4. Resume","text":"<p>Strategy:</p> <pre><code>SupervisorStrategy.resume()\n</code></pre> <p>Behavior:</p> <ul> <li>Exception is logged but ignored</li> <li>Actor continues processing next message</li> <li>Current state is preserved</li> <li>No restart occurs</li> </ul> <p>When to use:</p> <ul> <li>Non-critical failures that shouldn't disrupt operation</li> <li>Actors processing independent messages where one failure shouldn't stop others</li> <li>Logging/monitoring actors</li> <li>Best-effort processing scenarios</li> </ul> <p>Example scenario: A logging actor fails to write one log entry to a remote service. It should continue processing other log entries rather than stopping.</p>"},{"location":"examples/supervision/#choosing-the-right-strategy","title":"Choosing the Right Strategy","text":"<p>Use this decision tree to select an appropriate strategy:</p> <pre><code>Is the failure recoverable?\n\u251c\u2500 NO \u2192 Stop\n\u2514\u2500 YES\n   \u2514\u2500 Should we retry?\n      \u251c\u2500 NO \u2192 Resume (log and continue)\n      \u2514\u2500 YES\n         \u2514\u2500 Could infinite retries cause problems?\n            \u251c\u2500 YES \u2192 Restart (Limited)\n            \u2514\u2500 NO \u2192 Restart (Unlimited)\n</code></pre>"},{"location":"examples/supervision/#strategy-comparison","title":"Strategy Comparison","text":"Strategy State After Failure Continues Processing Automatic Retry Use Case Restart (Unlimited) Reset \u2705 (new instance) \u2705 Infinite Transient failures, stateless workers Restart (Limited) Reset \u2705 (until limit) \u2705 Limited Production systems, prevent loops Stop Lost \u274c \u274c Fatal errors, fail fast Resume Preserved \u2705 (same instance) \u274c Non-critical failures, best effort"},{"location":"examples/supervision/#interactive-demo","title":"Interactive Demo","text":""},{"location":"examples/supervision/#starting-the-application","title":"Starting the Application","text":"<pre><code>cd example/supervision\n./gradlew bootRun\n</code></pre> <p>Open your browser to: http://localhost:8080</p>"},{"location":"examples/supervision/#using-the-web-interface","title":"Using the Web Interface","text":"<p>The interactive UI provides:</p> <ol> <li> <p>Visual Hierarchy Tree</p> <ul> <li>Green circles represent actors</li> <li>Darker green = supervisors (manage children only)</li> <li>Lighter green = workers (can process tasks and supervise)</li> </ul> </li> <li> <p>Failure Count Badges</p> <ul> <li>Red badges show how many times each worker has failed</li> <li>Updated in real-time</li> <li>Persists across restarts</li> </ul> </li> <li> <p>Interactive Actions</p> <ul> <li>Add Child: Create a child actor with chosen strategy</li> <li>Send Work: Test the actor processes messages correctly</li> <li>Trigger Failure: Deliberately fail the actor to test supervision</li> <li>Stop: Manually terminate an actor</li> </ul> </li> <li> <p>Live Event Log</p> <ul> <li>Real-time stream of all actor events</li> <li>Shows spawns, failures, restarts, and stops</li> <li>Helps understand supervision behavior</li> </ul> </li> </ol>"},{"location":"examples/supervision/#state-management","title":"State Management","text":"<p>Understanding how state behaves across supervision actions:</p> Strategy Actor Instance Actor State Message Mailbox Restart New instance created Lost (reset to initial) Preserved (old messages reprocessed) Stop Terminated Lost Lost Resume Same instance Preserved Preserved (continues from next message) <p>Important: If you need to preserve state across restarts, consider:</p> <ul> <li>Persisting state to external storage (database, etc.)</li> <li>Using event sourcing patterns</li> <li>Implementing custom snapshot/recovery logic</li> </ul>"},{"location":"examples/supervision/#architecture-benefits","title":"Architecture Benefits","text":"<p>Supervision provides:</p> <p>\u2705 Fault Isolation - Failures don't cascade to unrelated actors \u2705 Self-Healing - Automatic recovery without manual intervention \u2705 Graceful Degradation - System continues operating despite component failures \u2705 Clear Error Boundaries - Supervision hierarchy defines failure domains \u2705 Observability - Real-time visibility into system health</p>"},{"location":"examples/supervision/#best-practices","title":"Best Practices","text":"<ol> <li>Choose strategies per actor type, not globally</li> <li>Use limited restart in production to prevent resource exhaustion</li> <li>Monitor restart rates to detect systemic issues</li> <li>Design for restart - assume actors can restart anytime</li> <li>Keep critical state external to survive restarts</li> <li>Use hierarchy for isolation - group related actors under supervisors</li> <li>Test failure scenarios before production deployment</li> </ol>"},{"location":"examples/supervision/#common-pitfalls","title":"Common Pitfalls","text":"<p>\u274c Using unlimited restart everywhere - Can hide persistent problems \u274c Using resume for critical failures - May continue with corrupted state \u274c Not monitoring failure rates - Miss signs of systemic issues \u274c Storing critical state in-memory only - Lost on restart \u274c Flat hierarchies - No fault isolation</p>"},{"location":"examples/synchronization/","title":"Synchronization Example","text":"<p>This guide demonstrates how to implement efficient synchronization using Spring Boot Starter Actor, comparing it with traditional synchronization approaches.</p>"},{"location":"examples/synchronization/#overview","title":"Overview","text":"<p>The synchronization example shows how to:</p> <ul> <li>Implement counters with different synchronization mechanisms</li> <li>Compare database locking, Redis locking, and actor-based synchronization</li> <li>Handle concurrent access to shared resources</li> <li>Achieve high performance with actor-based synchronization</li> </ul> <p>This example demonstrates why using actors for synchronization is cheap and efficient compared to other approaches.</p>"},{"location":"examples/synchronization/#source-code","title":"Source Code","text":"<p>You can find the complete source code for this example on GitHub: https://github.com/seonWKim/spring-boot-starter-actor/tree/main/example/synchronization</p>"},{"location":"examples/synchronization/#key-components","title":"Key Components","text":"<p>The example implements a counter service using three different synchronization approaches:</p> <ol> <li>Database Locking: Uses database transactions and locks</li> <li>Redis Locking: Uses Redis for distributed locking</li> <li>Actor-Based Synchronization: Uses actors for message-based synchronization</li> </ol> <p>Let's examine each approach to understand their differences and trade-offs.</p>"},{"location":"examples/synchronization/#counter-entity","title":"Counter Entity","text":"<p>The <code>Counter</code> class is a simple JPA entity representing a counter in the database:</p> <pre><code>@Entity\n@Table(name = \"counter\")\npublic class Counter {\n    @Id\n    @Column(name = \"counter_id\", nullable = false)\n    private String counterId;\n\n    @Column(name = \"value\", nullable = false)\n    private long value;\n\n    // Constructors, getters, setters...\n\n    public long increment() {\n        return ++value;\n    }\n}\n</code></pre>"},{"location":"examples/synchronization/#database-synchronization","title":"Database Synchronization","text":"<p><code>DbCounterService</code> uses database transactions and pessimistic locking to ensure synchronized access to counters:</p> <pre><code>@Service\npublic class DbCounterService implements CounterService {\n    private final CounterRepository counterRepository;\n    private final CustomTransactionTemplate customTransactionTemplate;\n\n    public DbCounterService(\n            CounterRepository counterRepository, \n            CustomTransactionTemplate customTransactionTemplate) {\n        this.counterRepository = counterRepository;\n        this.customTransactionTemplate = customTransactionTemplate;\n    }\n\n    @Override\n    public void increment(String counterId) {\n        incrementInternal(counterId);\n    }\n\n    @Override\n    public Mono&lt;Long&gt; getValue(String counterId) {\n        return Mono.fromCallable(() -&gt; getValueInternal(counterId))\n                .subscribeOn(Schedulers.boundedElastic());\n    }\n\n    public Long incrementInternal(String counterId) {\n        return customTransactionTemplate.runInTransaction(\n                () -&gt; {\n                    // Find counter with lock or create new one\n                    Counter counter =\n                            counterRepository\n                                    .findByIdWithLock(counterId)\n                                    .orElseGet(\n                                            () -&gt; {\n                                                return counterRepository.save(new Counter(counterId, 0));\n                                            });\n\n                    // Increment and save\n                    long newValue = counter.increment();\n                    counterRepository.save(counter);\n\n                    return newValue;\n                });\n    }\n\n    public Long getValueInternal(String counterId) {\n        return counterRepository.findById(counterId).map(Counter::getValue).orElse(0L);\n    }\n}\n</code></pre>"},{"location":"examples/synchronization/#redis-synchronization","title":"Redis Synchronization","text":"<p><code>RedisCounterService</code> uses Redis distributed locking to ensure synchronized access to counters:</p> <pre><code>@Service\npublic class RedisCounterService implements CounterService {\n    private static final String COUNTER_KEY_PREFIX = \"counter:\";\n    private static final String LOCK_KEY_PREFIX = \"counter:lock:\";\n    private static final Duration LOCK_TIMEOUT = Duration.ofSeconds(2);\n    private static final Duration RETRY_DELAY = Duration.ofMillis(100);\n    private static final int MAX_RETRIES = 50; // 5 seconds total retry time\n\n    private final ReactiveRedisTemplate&lt;String, Long&gt; redisTemplate;\n    private final ReactiveValueOperations&lt;String, Long&gt; valueOps;\n\n    public RedisCounterService(ReactiveRedisTemplate&lt;String, Long&gt; redisTemplate) {\n        this.redisTemplate = redisTemplate;\n        this.valueOps = redisTemplate.opsForValue();\n    }\n\n    @Override\n    public void increment(String counterId) {\n        String counterKey = COUNTER_KEY_PREFIX + counterId;\n        String lockKey = LOCK_KEY_PREFIX + counterId;\n\n        valueOps\n                .setIfAbsent(lockKey, 1L, LOCK_TIMEOUT)\n                .flatMap(locked -&gt; {\n                    if (!locked) {\n                        // Failed to acquire lock, retry\n                        return Mono.error(new RuntimeException(\"Failed to acquire lock\"));\n                    }\n\n                    return valueOps\n                            .increment(counterKey)\n                            .doFinally(signalType -&gt;\n                                       // Release lock when done\n                                       redisTemplate.delete(lockKey).subscribe());\n                })\n                .retryWhen(\n                        Retry.backoff(MAX_RETRIES, RETRY_DELAY))\n                .subscribe();\n    }\n\n    @Override\n    public Mono&lt;Long&gt; getValue(String counterId) {\n        String counterKey = COUNTER_KEY_PREFIX + counterId;\n        // Get the counter value or return 0 if it doesn't exist\n        return valueOps.get(counterKey).defaultIfEmpty(0L);\n    }\n}\n</code></pre>"},{"location":"examples/synchronization/#counteractor","title":"CounterActor","text":"<p><code>CounterActor</code> is a sharded actor that handles counter operations. Each counter is represented by a separate actor instance, identified by its counterId:</p> <pre><code>@Component\npublic class CounterActor implements ShardedActor&lt;CounterActor.Command&gt; {\n    public static final EntityTypeKey&lt;Command&gt; TYPE_KEY =\n            EntityTypeKey.create(Command.class, \"CounterActor\");\n\n    // Command interface and message types\n    public interface Command extends JsonSerializable {}\n\n    public static class Increment implements Command {\n\n        @JsonCreator\n        public Increment() {}\n    }\n\n    public static class GetValue implements Command {\n        public final ActorRef&lt;Long&gt; replyTo;\n\n        @JsonCreator\n        public GetValue(@JsonProperty(\"replyTo\") ActorRef&lt;Long&gt; replyTo) {\n            this.replyTo = replyTo;\n        }\n    }\n\n    // Implementation of ShardedActor methods...\n\n    private static class CounterActorBehavior {\n        private final ActorContext&lt;Command&gt; ctx;\n        private final String counterId;\n        private long value = 0;\n\n        // Constructor and behavior creation...\n\n        private Behavior&lt;Command&gt; onIncrement(Increment msg) {\n            value++;\n            return Behaviors.same();\n        }\n\n        private Behavior&lt;Command&gt; onGetValue(GetValue msg) {\n            msg.replyTo.tell(value);\n            return Behaviors.same();\n        }\n    }\n}\n</code></pre>"},{"location":"examples/synchronization/#actorcounterservice","title":"ActorCounterService","text":"<p><code>ActorCounterService</code> uses actor-based synchronization to handle counter operations:</p> <pre><code>@Service\npublic class ActorCounterService implements CounterService {\n    private final SpringActorSystem springActorSystem;\n\n    public ActorCounterService(SpringActorSystem springActorSystem) {\n        this.springActorSystem = springActorSystem;\n    }\n\n    @Override\n    public void increment(String counterId) {\n        // Get a reference to the sharded actor for this counter\n        SpringShardedActorRef&lt;CounterActor.Command&gt; actorRef =\n                springActorSystem.sharded(CounterActor.class).withId(counterId).get();\n\n        // Send an increment message to the actor\n        actorRef.tell(new CounterActor.Increment());\n    }\n\n    @Override\n    public Mono&lt;Long&gt; getValue(String counterId) {\n        // Get a reference to the sharded actor for this counter\n        SpringShardedActorRef&lt;CounterActor.Command&gt; actorRef =\n                springActorSystem.sharded(CounterActor.class).withId(counterId).get();\n\n        // Send a get value message to the actor and get the response\n        CompletionStage&lt;Long&gt; response =\n                actorRef.ask(replyTo -&gt; new CounterActor.GetValue(replyTo), TIMEOUT);\n\n        return Mono.fromCompletionStage(response);\n    }\n}\n</code></pre>"},{"location":"examples/synchronization/#countercontroller","title":"CounterController","text":"<p><code>CounterController</code> exposes the counter functionality via HTTP endpoints for all three synchronization approaches:</p> <pre><code>@RestController\n@RequestMapping(\"/counter\")\npublic class CounterController {\n    private final DbCounterService dbCounterService;\n    private final RedisCounterService redisCounterService;\n    private final ActorCounterService actorCounterService;\n\n    // Constructor and endpoint methods for each service...\n\n    @GetMapping(\"/actor/{counterId}/increment\")\n    public void incrementActorCounter(@PathVariable String counterId) {\n        actorCounterService.increment(counterId);\n    }\n\n    @GetMapping(\"/actor/{counterId}\")\n    public Mono&lt;Long&gt; getActorCounter(@PathVariable String counterId) {\n        return actorCounterService.getValue(counterId);\n    }\n}\n</code></pre>"},{"location":"examples/synchronization/#actor-efficiency","title":"Actor Efficiency","text":"<p>Actors provide efficient synchronization through:</p> <ul> <li>Message-based concurrency without explicit locks</li> <li>Non-blocking asynchronous processing</li> <li>Independent actors that scale across nodes</li> <li>Reduced contention between different counters</li> <li>Built-in supervision and error handling</li> </ul>"},{"location":"examples/synchronization/#performance-comparison","title":"Performance Comparison","text":"<p>When benchmarked under high concurrency:</p> <ol> <li>Database Locking: Slowest due to transaction overhead</li> <li>Redis Locking: Better but has network overhead</li> <li>Actor-Based Synchronization: Fastest with in-memory processing</li> </ol>"},{"location":"guides/actor-registration-messaging/","title":"Actor Registration and Messaging","text":"<p>This guide explains how to register actors, spawn them, and send messages using Spring Boot Starter Actor.</p>"},{"location":"guides/actor-registration-messaging/#registering-actors","title":"Registering Actors","text":"<p>In Spring Boot Starter Actor, actors are registered as Spring components. This allows them to be automatically discovered and managed by the Spring container.</p>"},{"location":"guides/actor-registration-messaging/#creating-a-simple-actor","title":"Creating a Simple Actor","text":"<p>To create an actor, implement the <code>SpringActor</code> interface and annotate the class with <code>@Component</code>:</p> <pre><code>import io.github.seonwkim.core.SpringActor;\nimport io.github.seonwkim.core.SpringActorContext;\n\nimport org.apache.pekko.actor.typed.ActorRef;\nimport org.apache.pekko.actor.typed.Behavior;\nimport org.apache.pekko.actor.typed.javadsl.ActorContext;\nimport org.apache.pekko.actor.typed.javadsl.Behaviors;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class HelloActor implements SpringActor&lt;HelloActor, HelloActor.Command&gt; {\n\n    // Define the command interface for messages this actor can handle\n    public interface Command {}\n\n    // Define a message type \n    public static class SayHi implements Command {}\n\n    // Define a message type\n    public static class SayHello implements Command {\n        public final ActorRef&lt;String&gt; replyTo;\n\n        public SayHello(ActorRef&lt;String&gt; replyTo) {\n            this.replyTo = replyTo;\n        }\n    }\n\n    // Create the behavior for this actor\n    @Override\n    public Behavior&lt;Command&gt; create(SpringActorContext actorContext) {\n        return Behaviors.setup(ctx -&gt; new HelloActorBehavior(ctx, actorContext).create());\n    }\n\n    // Inner class to handle the actor's behavior\n    private static class HelloActorBehavior {\n        private final ActorContext&lt;Command&gt; ctx;\n        private final SpringActorContext actorContext;\n\n        HelloActorBehavior(ActorContext&lt;Command&gt; ctx, SpringActorContext actorContext) {\n            this.ctx = ctx;\n            this.actorContext = actorContext;\n        }\n\n        public Behavior&lt;Command&gt; create() {\n            return Behaviors.receive(Command.class)\n                            .onMessage(SayHi.class, this::onSayHi)\n                            .onMessage(SayHello.class, this::onSayHello)\n                            .build();\n        }\n\n        private Behavior&lt;Command&gt; onSayHi(SayHi msg) {\n            ctx.getLog().info(\"Received SayHi for id={}\", actorId);\n            return Behaviors.same(); \n        }\n\n        private Behavior&lt;Command&gt; onSayHello(SayHello msg) {\n            ctx.getLog().info(\"Received SayHello for id={}\", actorContext.getId());\n            msg.replyTo.tell(\"Hello from actor \" + actorId);\n            return Behaviors.same();\n        }\n    }\n}\n</code></pre>"},{"location":"guides/actor-registration-messaging/#spawning-actors","title":"Spawning Actors","text":"<p>Once you've registered your actor, you can spawn instances of it using the <code>SpringActorSystem</code>:</p>"},{"location":"guides/actor-registration-messaging/#simplified-api","title":"Simplified API","text":"<p>The recommended way to spawn actors is using the fluent builder API:</p> <pre><code>import io.github.seonwkim.core.SpringActorRef;\nimport io.github.seonwkim.core.SpringActorSystem;\n\nimport org.springframework.stereotype.Service;\n\nimport java.time.Duration;\n\nimport reactor.core.publisher.Mono;\n\n@Service\npublic class HelloService {\n\n    private final SpringActorRef&lt;HelloActor.Command&gt; helloActor;\n\n    public HelloService(SpringActorSystem springActorSystem) {\n        // Spawn an actor using the fluent builder API\n        this.helloActor = springActorSystem\n                .actor(HelloActor.class)\n                .withId(\"default\")\n                .withTimeout(Duration.ofSeconds(3))\n                .startAndWait();\n    }\n\n    // Service methods...\n}\n</code></pre>"},{"location":"guides/actor-registration-messaging/#async-spawning","title":"Async Spawning","text":"<p>For non-blocking actor creation:</p> <pre><code>@Service\npublic class HelloService {\n    private final CompletionStage&lt;SpringActorRef&lt;HelloActor.Command&gt;&gt; helloActor;\n\n    public HelloService(SpringActorSystem springActorSystem) {\n        // Spawn asynchronously\n        this.helloActor = springActorSystem\n                .actor(HelloActor.class)\n                .withId(\"default\")\n                .withTimeout(\"3s\")  // Can use string format\n                .start();\n    }\n\n    public Mono&lt;String&gt; hello() {\n        return Mono.fromCompletionStage(\n            helloActor.thenCompose(actor -&gt;\n                actor.ask(HelloActor.SayHello::new, Duration.ofSeconds(3))\n            )\n        );\n    }\n}\n</code></pre>"},{"location":"guides/actor-registration-messaging/#advanced-configuration","title":"Advanced Configuration","text":"<p>The fluent API supports additional configuration options:</p> <pre><code>SpringActorRef&lt;HelloActor.Command&gt; actor = springActorSystem\n        .actor(HelloActor.class)\n        .withId(\"myActor\")\n        .withTimeout(Duration.ofSeconds(5))\n        .withMailbox(\"bounded\")  // or \"unbounded\", \"default\"\n        .asClusterSingleton()     // For cluster singleton actors\n        .withContext(customContext)  // Custom actor context\n        .start();\n</code></pre>"},{"location":"guides/actor-registration-messaging/#sending-messages-to-actors","title":"Sending Messages to Actors","text":"<p>Once you have a reference to an actor, you can send messages to it:</p>"},{"location":"guides/actor-registration-messaging/#tell-pattern-fire-and-forget","title":"Tell Pattern (Fire-and-Forget)","text":"<p>The tell pattern is used when you don't need a response from the actor:</p> <pre><code>public void hi() {\n    helloActor.tell(HelloActor.SayHi::new);\n}\n</code></pre>"},{"location":"guides/actor-registration-messaging/#ask-pattern-request-response","title":"Ask Pattern (Request-Response)","text":"<p>The ask pattern is used when you expect a response from the actor:</p> <pre><code>public Mono&lt;String&gt; hello() {\n    return Mono.fromCompletionStage(\n            helloActor.ask(HelloActor.SayHello::new, Duration.ofSeconds(3)));\n}\n</code></pre>"},{"location":"guides/actor-registration-messaging/#stopping-actors","title":"Stopping Actors","text":"<p>You can gracefully stop actors when they are no longer needed:</p>"},{"location":"guides/actor-registration-messaging/#simplified-stop-api","title":"Simplified Stop API","text":"<pre><code>actorRef.stop(); \n</code></pre>"},{"location":"guides/actor-registration-messaging/#actor-lifecycle-operations","title":"Actor Lifecycle Operations","text":""},{"location":"guides/actor-registration-messaging/#checking-if-an-actor-exists","title":"Checking if an Actor Exists","text":"<p>Check if an actor is already running before creating a new instance:</p> <pre><code>CompletionStage&lt;Boolean&gt; exists = actorSystem\n    .exists(MyActor.class, \"my-actor-1\");\n\n// With custom timeout\nexists = actorSystem.exists(MyActor.class, \"my-actor-1\", Duration.ofMillis(500));\n</code></pre>"},{"location":"guides/actor-registration-messaging/#getting-an-existing-actor-reference","title":"Getting an Existing Actor Reference","text":"<p>Retrieve a reference to an existing actor without creating a new instance:</p> <pre><code>CompletionStage&lt;SpringActorRef&lt;Command&gt;&gt; actorRef = actorSystem\n    .get(MyActor.class, \"my-actor-1\");\n\n// With custom timeout\nactorRef = actorSystem.get(MyActor.class, \"my-actor-1\", Duration.ofMillis(500));\n\n// Returns null if actor doesn't exist\n</code></pre>"},{"location":"guides/actor-registration-messaging/#get-or-create-pattern-recommended","title":"Get or Create Pattern (Recommended)","text":"<p>Simple Approach - Use <code>getOrSpawn</code>:</p> <p>The <code>getOrSpawn</code> method automatically handles the exists/get/spawn logic:</p> <pre><code>// Recommended: Use getOrSpawn for simplified actor lifecycle management\nCompletionStage&lt;SpringActorRef&lt;Command&gt;&gt; actorRef = actorSystem\n    .getOrSpawn(MyActor.class, \"my-actor-1\");\n\n// With custom timeout\nactorRef = actorSystem.getOrSpawn(MyActor.class, \"my-actor-1\", Duration.ofSeconds(5));\n</code></pre> <p>Manual Approach (for advanced cases):</p> <p>If you need more control, you can manually check exists and spawn:</p> <pre><code>actorSystem.exists(MyActor.class, \"my-actor-1\")\n    .thenCompose(exists -&gt; {\n        if (exists) {\n            return actorSystem.get(MyActor.class, \"my-actor-1\");\n        } else {\n            return actorSystem.actor(MyActor.class)\n                .withId(\"my-actor-1\")\n                .start();\n        }\n    });\n</code></pre>"},{"location":"guides/actor-registration-messaging/#lazy-initialization-pattern","title":"Lazy Initialization Pattern","text":"<p>Simple Approach (Recommended for most cases):</p> <p>Use <code>getOrSpawn</code> directly - it's simple, efficient, and handles the lifecycle automatically:</p> <pre><code>@Service\npublic class HelloService {\n    private final SpringActorSystem actorSystem;\n\n    public HelloService(SpringActorSystem actorSystem) {\n        this.actorSystem = actorSystem;\n    }\n\n    /**\n     * getOrSpawn handles the exists/get/spawn logic automatically.\n     * This is the recommended approach for most use cases.\n     */\n    public Mono&lt;String&gt; hello() {\n        return Mono.fromCompletionStage(\n                actorSystem.getOrSpawn(HelloActor.class, \"hello-actor\")\n                        .thenCompose(actor -&gt; actor.ask(HelloActor.SayHello::new)));\n    }\n}\n</code></pre> <p>With Caching (For high-frequency access):</p> <p>If the same actor is accessed very frequently, cache the reference to avoid repeated lookups:</p> <pre><code>@Service\npublic class HelloService {\n    private final SpringActorSystem actorSystem;\n    private final AtomicReference&lt;CompletionStage&lt;SpringActorRef&lt;HelloActor.Command&gt;&gt;&gt; actorRef =\n            new AtomicReference&lt;&gt;();\n\n    public HelloService(SpringActorSystem actorSystem) {\n        this.actorSystem = actorSystem;\n    }\n\n    /**\n     * Lazily initializes the actor on first use and caches the reference\n     * for subsequent calls. Use this for high-frequency access scenarios.\n     */\n    private CompletionStage&lt;SpringActorRef&lt;HelloActor.Command&gt;&gt; getActor() {\n        return actorRef.updateAndGet(existing -&gt;\n                existing != null ? existing : actorSystem.getOrSpawn(HelloActor.class, \"hello-actor\")\n        );\n    }\n\n    public Mono&lt;String&gt; hello() {\n        return Mono.fromCompletionStage(\n                getActor().thenCompose(actor -&gt; actor.ask(HelloActor.SayHello::new)));\n    }\n}\n</code></pre>"},{"location":"guides/actor-registration-messaging/#best-practices","title":"Best Practices","text":"<ol> <li>Use getOrSpawn: For most cases, use <code>getOrSpawn()</code> instead of manually checking exists/get/spawn - it's simpler and reduces boilerplate.</li> <li>Lazy Initialization: Use lazy initialization to avoid blocking application startup. For simple cases, use <code>getOrSpawn</code> directly; for high-frequency access, add caching with <code>AtomicReference</code>.</li> <li>Actor Hierarchy: Organize actors in a hierarchy to manage their lifecycle and supervision.</li> <li>Message Immutability: Ensure that messages sent to actors are immutable to prevent concurrency issues.</li> <li>Timeout Handling: Always specify reasonable timeouts for ask operations and handle timeout exceptions using <code>askBuilder().onTimeout()</code>.</li> <li>Non-Blocking Operations: Avoid blocking operations inside actors, as they can lead to thread starvation.</li> <li>Actor Naming: Use meaningful and unique names for actors to make debugging easier.</li> <li>Prefer Fluent API: Use the fluent builder API for spawning actors as it provides better readability and type safety.</li> </ol>"},{"location":"guides/actor-registration-messaging/#next-steps","title":"Next Steps","text":"<p>Now that you know how to register actors, spawn them, and send messages, you can:</p> <ol> <li>Learn how to create sharded actors for clustered environments</li> <li>Explore the API Reference for detailed information about the library's APIs</li> </ol>"},{"location":"guides/sharded-actors/","title":"Sharded Actors","text":"<p>This guide explains how to create and use sharded actors in a clustered environment using Spring Boot Starter Actor.</p>"},{"location":"guides/sharded-actors/#what-are-sharded-actors","title":"What are Sharded Actors?","text":"<p>Sharded actors are actors that are distributed across multiple nodes in a cluster. Each actor instance (entity) is responsible for a specific entity ID, and the cluster ensures that only one instance of an entity exists across the entire cluster at any given time.</p> <p>Sharding is useful when:</p> <ul> <li>You need to distribute actor instances across multiple nodes</li> <li>You have a large number of actors that would be too much for a single node</li> <li>You want automatic rebalancing of actors when nodes join or leave the cluster</li> </ul>"},{"location":"guides/sharded-actors/#setting-up-a-cluster","title":"Setting Up a Cluster","text":"<p>Before you can use sharded actors, you need to set up a Pekko cluster. Add the following configuration to your <code>application.yaml</code> file:</p> <pre><code>spring:\n  application:\n    name: spring-pekko\n  actor:\n    pekko:\n      name: spring-pekko-example\n      actor:\n        provider: cluster\n        allow-java-serialization: off\n        warn-about-java-serializer-usage: on\n      remote:\n        artery:\n          canonical:\n            hostname: 127.0.0.1\n            port: 2551\n      cluster:\n        name: spring-pekko-example\n        seed-nodes:\n          - pekko://spring-pekko-example@127.0.0.1:2551\n          - pekko://spring-pekko-example@127.0.0.1:2552\n          - pekko://spring-pekko-example@127.0.0.1:2553\n        downing-provider-class: org.apache.pekko.cluster.sbr.SplitBrainResolverProvider\n\nserver:\n  port: 8080\n</code></pre> <p>Make sure to adjust the hostname, port, and seed-nodes according to your environment.</p>"},{"location":"guides/sharded-actors/#creating-a-sharded-actor","title":"Creating a Sharded Actor","text":"<p>To create a sharded actor, implement the <code>ShardedActor</code> interface and annotate the class with <code>@Component</code>:</p> <pre><code>import com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\nimport io.github.seonwkim.core.serialization.JsonSerializable;\nimport io.github.seonwkim.core.shard.DefaultShardingMessageExtractor;\nimport io.github.seonwkim.core.shard.ShardEnvelope;\nimport io.github.seonwkim.core.shard.ShardedActor;\n\nimport org.apache.pekko.actor.typed.ActorRef;\nimport org.apache.pekko.actor.typed.Behavior;\nimport org.apache.pekko.actor.typed.javadsl.Behaviors;\nimport org.apache.pekko.cluster.sharding.typed.ShardingMessageExtractor;\nimport org.apache.pekko.cluster.sharding.typed.javadsl.EntityContext;\nimport org.apache.pekko.cluster.sharding.typed.javadsl.EntityTypeKey;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class HelloActor implements ShardedActor&lt;HelloActor.Command&gt; {\n\n    public static final EntityTypeKey&lt;Command&gt; TYPE_KEY =\n            EntityTypeKey.create(Command.class, \"HelloActor\");\n\n    // Define the command interface for messages this actor can handle\n    public interface Command extends JsonSerializable {}\n\n    // Define a message type\n    public static class SayHello implements Command {\n        public final ActorRef&lt;String&gt; replyTo;\n        public final String message;\n\n        @JsonCreator\n        public SayHello(\n                @JsonProperty(\"replyTo\") ActorRef&lt;String&gt; replyTo,\n                @JsonProperty(\"message\") String message) {\n            this.replyTo = replyTo;\n            this.message = message;\n        }\n    }\n\n    @Override\n    public EntityTypeKey&lt;Command&gt; typeKey() {\n        return TYPE_KEY;\n    }\n\n    @Override\n    public Behavior&lt;Command&gt; create(EntityContext&lt;Command&gt; ctx) {\n        return Behaviors.setup(\n                context -&gt;\n                        Behaviors.receive(Command.class)\n                                 .onMessage(\n                                         SayHello.class,\n                                         msg -&gt; {\n                                             // Get information about the current node and entity\n                                             final String nodeAddress =\n                                                     context.getSystem().address().toString();\n                                             final String entityId = ctx.getEntityId();\n\n                                             // Create a response message with node and entity information\n                                             final String message =\n                                                     \"Received from entity [\" + entityId + \"] on node [\"\n                                                     + nodeAddress + \"]\";\n\n                                             // Send the response back to the caller\n                                             msg.replyTo.tell(message);\n\n                                             // Log the message for debugging\n                                             context.getLog().info(message);\n\n                                             return Behaviors.same();\n                                         })\n                                 .build());\n    }\n\n    @Override\n    public ShardingMessageExtractor&lt;ShardEnvelope&lt;Command&gt;, Command&gt; extractor() {\n        return new DefaultShardingMessageExtractor&lt;&gt;(3);\n    }\n}\n</code></pre> <p>Key differences from a regular actor:</p> <ol> <li>Implement <code>ShardedActor&lt;T&gt;</code> instead of <code>SpringActor</code></li> <li>Commands must implement <code>JsonSerializable</code>(or <code>CborSerializable</code>) for serialization across the network</li> <li>Define an <code>EntityTypeKey</code> for the actor type</li> <li>Override <code>typeKey()</code> to return the EntityTypeKey</li> <li>Override <code>create(EntityContext&lt;T&gt;)</code> instead of <code>create(String)</code></li> <li>Override <code>extractor()</code> to provide a sharding message extractor</li> <li>Use Jackson annotations (<code>@JsonCreator</code>, <code>@JsonProperty</code>) for message serialization</li> </ol>"},{"location":"guides/sharded-actors/#interacting-with-sharded-actors","title":"Interacting with Sharded Actors","text":"<p>To interact with sharded actors, you use the <code>sharded</code> method of the <code>SpringActorSystem</code>:</p> <pre><code>import io.github.seonwkim.core.SpringActorSystem;\nimport io.github.seonwkim.core.SpringShardedActorRef;\n\nimport java.time.Duration;\nimport java.util.concurrent.CompletionStage;\n\nimport org.springframework.stereotype.Service;\n\nimport reactor.core.publisher.Mono;\n\n@Service\npublic class HelloService {\n\n    private final SpringActorSystem springActorSystem;\n\n    public HelloService(SpringActorSystem springActorSystem) {\n        this.springActorSystem = springActorSystem;\n    }\n\n    /**\n     * Best practice for sharded actors:\n     * - Get reference on each request (references are lightweight)\n     * - No need to cache (entities are managed by cluster sharding)\n     * - No need to check existence (entities are created on-demand)\n     * - Use askBuilder for timeout and error handling\n     */\n    public Mono&lt;String&gt; hello(String message, String entityId) {\n        // Get a reference to the sharded actor entity\n        SpringShardedActorRef&lt;HelloActor.Command&gt; actorRef =\n                springActorSystem.sharded(HelloActor.class).withId(entityId).get();\n\n        // Send the message using the fluent ask builder with timeout and error handling\n        CompletionStage&lt;String&gt; response = actorRef.askBuilder(\n                        replyTo -&gt; new HelloActor.SayHello(replyTo, message))\n                .withTimeout(Duration.ofSeconds(3))\n                .onTimeout(() -&gt; \"Request timed out for entity: \" + entityId)\n                .execute();\n\n        // Convert the CompletionStage to a Mono for reactive programming\n        return Mono.fromCompletionStage(response);\n    }\n}\n</code></pre> <p>The <code>sharded</code> method creates a builder that:</p> <ol> <li>Takes the actor class as a parameter</li> <li>Requires setting the entity ID using <code>withId()</code></li> <li>Returns the actor reference with <code>get()</code></li> </ol> <p>The builder pattern provides a more fluent API and automatically resolves the <code>EntityTypeKey</code> from the actor class.</p>"},{"location":"guides/sharded-actors/#key-differences-from-regular-actors","title":"Key Differences from Regular Actors","text":"<p>Sharded actors behave differently from regular actors:</p> <ol> <li>No <code>start()</code> needed: Entities are created automatically when the first message arrives</li> <li>Always available: Entity references are always valid, even if the entity isn't currently running</li> <li>Auto-distribution: Entities are automatically distributed across cluster nodes</li> <li>Auto-passivation: Entities are automatically stopped after idle timeout (configurable)</li> <li>Lightweight references: Getting a reference doesn't create the entity, so no caching needed</li> <li>No exists/get checks: The cluster sharding coordinator manages entity lifecycle</li> </ol> <p>Example - Regular Actor vs Sharded Actor:</p> <pre><code>// Regular Actor - needs explicit lifecycle management\nCompletionStage&lt;SpringActorRef&lt;Command&gt;&gt; actor = actorSystem\n    .exists(MyActor.class, \"actor-1\")\n    .thenCompose(exists -&gt; {\n        if (exists) {\n            return actorSystem.get(MyActor.class, \"actor-1\");\n        } else {\n            return actorSystem.actor(MyActor.class)\n                .withId(\"actor-1\")\n                .start();\n        }\n    });\n\n// Sharded Actor - just get the reference and use it\nSpringShardedActorRef&lt;Command&gt; actor = actorSystem\n    .sharded(MyShardedActor.class)\n    .withId(\"actor-1\")\n    .get();\n</code></pre>"},{"location":"guides/sharded-actors/#using-sharded-actors-in-a-rest-controller","title":"Using Sharded Actors in a REST Controller","text":"<p>Here's an example of how to use the sharded actor service in a REST controller:</p> <pre><code>import org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport reactor.core.publisher.Mono;\n\n@RestController\npublic class HelloController {\n\n    private final HelloService helloService;\n\n    public HelloController(HelloService helloService) {\n        this.helloService = helloService;\n    }\n\n    @GetMapping(\"/hello\")\n    public Mono&lt;String&gt; hello(@RequestParam String message, @RequestParam String entityId) {\n        return helloService.hello(message, entityId);\n    }\n}\n</code></pre>"},{"location":"guides/sharded-actors/#entity-id-strategies","title":"Entity ID Strategies","text":"<p>The entity ID is a crucial part of sharding. It determines which shard an entity belongs to, and therefore which node in the cluster will host the entity. Here are some strategies for choosing entity IDs:</p> <ol> <li>Natural Keys: Use existing business identifiers (e.g., user IDs, order numbers)</li> <li>Composite Keys: Combine multiple fields to form a unique identifier</li> <li>Hash-Based Keys: Generate a hash from the entity's data</li> <li>UUID: Generate a random UUID for each entity</li> </ol> <p>Choose a strategy that ensures even distribution of entities across shards while maintaining the ability to locate entities when needed.</p>"},{"location":"guides/sharded-actors/#sharding-configuration","title":"Sharding Configuration","text":"<p>You can configure sharding behavior using the <code>extractor()</code> method in your sharded actor:</p> <pre><code>@Override\npublic ShardingMessageExtractor&lt;ShardEnvelope&lt;Command&gt;, Command&gt; extractor() {\n    return new DefaultShardingMessageExtractor&lt;&gt;(numberOfShards);\n}\n</code></pre> <p>The <code>DefaultShardingMessageExtractor</code> takes a parameter that specifies the number of shards to use. More shards allow for finer-grained distribution but increase overhead.</p>"},{"location":"guides/sharded-actors/#best-practices-for-sharded-actors","title":"Best Practices for Sharded Actors","text":"<ol> <li>Don't Cache References: Get references on each request - they're lightweight and don't create entities</li> <li>Use askBuilder: Always use <code>askBuilder()</code> with timeout and error handling for production code</li> <li>Design for Idempotency: Messages may be redelivered during rebalancing, so design handlers to be idempotent</li> <li>Choose Entity IDs Wisely: Use natural business keys for even distribution across shards</li> <li>Avoid Cross-Entity Dependencies: Minimize communication between entities to reduce network overhead</li> <li>Monitor Shard Distribution: Use built-in metrics to ensure entities are evenly distributed</li> <li>Configure Passivation: Tune idle timeout based on your use case to balance memory and startup costs</li> <li>Use JSON Serialization: Prefer <code>JsonSerializable</code> over Java serialization for better performance and compatibility</li> </ol>"},{"location":"guides/sharded-actors/#comparison-regular-vs-sharded-actors","title":"Comparison: Regular vs Sharded Actors","text":"Feature Regular Actor Sharded Actor Lifecycle Manual (spawn/start/stop) Automatic (on-demand) Distribution Single node Distributed across cluster Reference Creation Heavy (creates actor) Lightweight (just reference) Caching Required for performance Not needed Existence Check Use <code>exists()</code> Not needed Serialization Not required Required (<code>JsonSerializable</code>) Use Case Local, long-lived actors Distributed, large-scale entities"},{"location":"guides/sharded-actors/#next-steps","title":"Next Steps","text":"<p>Now that you know how to create and use sharded actors, you can:</p> <ol> <li>Explore the API Reference for detailed information about the library's APIs</li> <li>Learn about advanced topics like persistence, event sourcing, and cluster singleton actors</li> </ol>"}]}